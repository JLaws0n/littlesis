<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class Relationship extends BaseRelationship
{
  private $_updateLinkFields = false;
  

  /**
   * Protected class variables for managing the Relationship's category
   */
  protected
    $_category = null,
    $_categoryObject = null,
    $_categoryLoaded = false,
    $_removedCategoryObject = null,
    $_isMerge = false;


  public function setMerge($bool)
  {
    $this->_isMerge = (bool) $bool;
  }
  

  public function isMerge()
  {
    return $this->_isMerge;
  }



  public function __toString()
  {
    return $this->getName();
  }


  /**
   * Generates a name for the Relationship (primarily for use by LsVersionableListener)
   *
   * @return  string  The generated name
   */
  public function getName()
  {
    //return generic name if components are missing
    if (!$this->category_id)
    {
      $ret = 'Relationship';
    }
    else
    {
      $ret = RelationshipCategoryTable::getDisplayNameById($this->category_id);
    }
    
    $ret .= ' ' . $this->id;

    if ($this->is_deleted)
    {
      $ret .= ' [deleted]';
    }
    
    return $ret;
  }


  
  /**
   * Generates internal url for Relationship profile page, or modifications page if deleted
   *
   * @return string
   */
  public function getInternalUrl($action=null, Array $params=null, $hideParams=false)
  {
    return RelationshipTable::generateRoute($this, $action, $params, $hideParams);
  }
  

  /**
   * Loads category data
   *
   * @param   boolean   $force  Loads even if _categoryLoaded is true
   */
  private function _loadCategory($force=false)
  {
    if ($this->id && ($force || !$this->_categoryLoaded))
    {
      $this->_loadRelationshipCategory();
      $this->_loadCategoryObject();
      $this->_categoryLoaded = true;
    }
  }


  /**
   * Loads RelationshipCategory object into _category using Relationship's category_id
   */
  private function _loadRelationshipCategory()
  {
    //Relationship must exist to load category info
    if (!$this->id)
    {
      throw new Exception('Cannot load category for new Relationship');
    }
    

    $this->_category = LsDoctrineQuery::create()
      ->from('RelationshipCategory c')
      ->where('c.id = ?', $this->category_id)
      ->fetchOne();
  }


  /**
   * Loads category object into _categoryObject if Relationship's category has fields
   */
  private function _loadCategoryObject()
  {
    //Relationship must exist to load category info
    if (!$this->id)
    {
      throw new Exception('Cannot load category object for new Relationship');
    }
    
    if ($this->_category && $this->_category->has_fields)
    {    
      $name = $this->_category->name;
      $lower = strtolower($name);
      
      $this->_categoryObject = LsDoctrineQuery::create()
        ->from($name . ' ' . $lower)
        ->where($lower . '.relationship_id = ?', $this->id)
        ->fetchOne();
    }
  }

  /**
   * Interface for setting a Relationship's category.
   *
   * @param   mixed   $category   A RelationshipCategory object or name
   * @return  boolean             Whether the category was set
   */
  public function setCategory($category)
  {
    if ($category instanceOf RelationshipCategory)
    {
      if (!$category->exists())
      {
        throw new Exception("Can't set new RelationshipCategory to Relationship");
      }
      elseif (!$category->name || in_array('name', $category->getModified()))
      {
        throw new Exception("RelationshipCategory must have unmodified name");
      }
      
      $name = $category->name;
    }
    else
    {
      $name = $category;
      
      if (!$category = Doctrine::getTable('RelationshipCategory')->findOneByName($name))
      {
        throw new Exception('No category exists with name ' . $name);
      }
    }    
    
    //check for existing category
    if ($existingCategory = $this->getCategory())
    {
      //if it's different, save existing category object for deletion
      if ($existingCategory->name != $name)
      {
        $object = $this->getCategoryObject();
      
        if ($object->exists())
        {
          $this->_removedCategoryObject = $object;
        }
      }
      else
      {
        //otherwise, no action necessary
        return false;
      }
    }
    
    //set category variables
    $this->category_id = $category->id;
    $this->_category = $category;
    
    if ($this->_category->has_fields)
    {
      $this->_categoryObject = new $name;
    }
        
    $this->_categoryLoaded = true;
    
    return true;
  }


  /**
   * Returns the RelationshipCategory object, if set
   *
   * @return  mixed   The RelationshipCategory or NULL
   */
  public function getCategory()
  {
    $this->_loadCategory();
    
    return $this->_category;
  }


  public function getCategoryName()
  {
    if ($name = RelationshipCategoryTable::getNameById($this->category_id))
    {
      return $name;
    }

    if ($category = $this->getCategory())
    {
      return $category->name;
    }
    
    return null;
  }
  
  
  public function getCategoryDefaultDescription()
  {
    if ($name = RelationshipCategoryTable::getDefaultDescriptionById($this->category_id))
    {
      return $name;
    }

    if ($category = $this->getCategory())
    {
      return $category->default_description;
    }
    
    return null;  
  }


  /**
   * Returns the category object, if set; eg, the Position or Education objects
   *
   * @return  mixed   The category object or NULL
   */  
  public function getCategoryObject()
  {
    $this->_loadCategory();
    
    return $this->_categoryObject;    
  }

  
  /**
   * Returns whether the Relation's category has fields, mostly to know whether
   * there is a category object to load
   * 
   * @return  boolean   Whether the Relation's category has fields
   */  
  public function categoryHasFields()
  {
    if ($category = $this->getCategory())
    {
      return $category->has_fields ? true : false;
    }

    return false;
  }
 
  /**
   * Returns an arary of Relationship and category fields and their values
   *
   * @param   boolean   $includeRelations   Whether to include relation names like Category; false by default
   * @param   array                         Associative array of fields and values 
   */
  public function getAllData($includeRelations=false)
  {
    $data = $this->toArray($includeRelations);
    
    foreach ($this->getCategoryData($includeRelations) as $field => $value)
    {
      $data[$field] = $value;
    }
    
    return $data;
  }
  
    
  /**
   * Returns an array of category fields and values
   *
   * @param   boolean   $includeRelations   Whether to include relation names; false by default
   * @return  array                         Associative array of category fields and their values
   */  
  public function getCategoryData($includeRelations=false)
  {
    $data = array();
    
    if ($object = $this->getCategoryObject())
    {
      foreach ($object->getData() as $field => $value)
      {
        if (!in_array($field, array('id', 'relationship_id')))
        {
          $data[$field] = $value;
        }      
      }
    }

    return $data;  
  }


  /**
   * Returns an array of Relationship and category field names
   *
   * @param   boolean   $includeRelations   Whether to include relation names; false by default
   * @return  array                         Array of field names
   */
  public function getAllFields($includeRelations=false)
  {
    $catFields = $this->getCategoryFields($includeRelations);

    return array_unique(array_merge($catFields, array_keys($this->toArray($includeRelations))));
  }


  /**
   * Returns array of modified Relationship and category field names
   *
   * @return  array   Array of modified field names
   */
  public function getAllModifiedFields()
  {
    $allowedFields = array_diff($this->getAllFields(), array('id'));
    
    
    $relFields = array_keys($this->getModified());
    $catFields = array();

    if ($object = $this->getCategoryObject())
    {
      $catFields = array_keys($object->getModified());
    }
    
    
    $removedFields = array();
    
    if ($this->_removedCategoryObject)
    {
      $removedFields = array_keys($this->_removedCategoryObject->getData());
    }
    
    $removedFields = array_diff($removedFields, array('id', 'relationship_id'));
    
    
    $fields = array_intersect($allowedFields, array_merge($relFields, $catFields));
    $fields = array_unique(array_merge($fields, $removedFields));
    
    return $fields;
  }


  public function getOldData()
  {
    $data = LsVersionable::getOldRecordData($this);

    if ($object = $this->getCategoryObject())
    {
      $extData = LsVersionable::getOldRecordData($object);      
      $data = array_merge($data, $extData);
    }

    if ($object = $this->_removedCategoryObject)
    {
      $extData = LsVersionable::getOldRecordData($object);      
      $data = array_merge($data, $extData);
    }
    
    return $data;
  }
  
  
  public function getOldRecord()
  {
    $old = new Relationship;
    
    if ($name = $this->getCategoryName())
    {
      $old->setCategory($name);
    }
        
    $old->fromArray($this->getOldData(), null, true);
    
    return $old;  
  }


  public function getRelationAliasByFieldName($fieldName)
  {
    $object = $this->getInvoker();
    $table = $object->getTable();
    
    foreach ($table->getRelations() as $name => $relation)
    {
      if ($relation->getLocalFieldName() == $fieldName)
      {
        return $name;
      }
    }
    
    if ($object = $this->getCategoryObject())
    {
      if ($name = LsVersionable::getRelationAliasByRecordAndFieldName($object, $fieldName))
      {
        return $name;
      }
    }
    
    return null;
  }


  /**
   * Returns an array of category field names
   *
   * @param   boolean   $includeRelations   Whether to include relation names; false by default
   * @return  array                         Array of field names
   */
  public function getCategoryFields($includeRelations=false)
  {
    $fields = array();

    if ($category = $this->getCategory())
    {
      $categoryName = $category->name;
      $object = new $categoryName;
      $table = $object->getTable();

      foreach ($table->getFieldNames() as $fieldName)
      {
        $fields[] = $fieldName;
      }
      
      if ($includeRelations)
      {
        foreach (array_keys($table->getRelations()) as $fieldName)
        {
          $fields[] = $fieldName;
        }
      }
    }
    
    return $fields;
  }
  
  
  /**
   * Returns an array of the category's methods
   *
   * @return  array   An array of method names
   */  
  public function getCategoryMethods()
  {
    $ret = array();
    
    if ($category = $this->getCategory())
    {
      $categoryName = $category->name;
      $object = new $categoryName;
      $methods = (array) get_class_methods($object);
      
      foreach ($methods as $method)
      {
        $ret[] = $method;
      }
    }

    return $ret;
  }


  /**
   * Sets a Relationship field, or a category field, to a given value
   *
   * @see Doctrine_Record
   */  
  public function set($fieldName, $value, $load=true)
  {
    //try Relationship first
    if (array_key_exists($fieldName, $this->_data) || $this->_table->hasRelation($fieldName))
    {
      return parent::set($fieldName, $value, $load);
    }


    //then try the category
    $fields = $this->getCategoryFields(true);
    
    if (in_array($fieldName, $fields))
    {
      $this->_categoryObject->set($fieldName, $value, $load);    
    }
    else
    {
      //the field doesn't exist: do what the parent would do
      parent::set($fieldName, $value, $load);
    }

    return $this;
  }


  /**
   * Returns Relationship field value, or category field value
   *
   * @see Doctrine_Record
   */
  public function get($fieldName, $load=true)
  {
    //try Relationship first
    if (array_key_exists($fieldName, $this->_data) || $this->_table->hasRelation($fieldName))
    {
      return parent::get($fieldName, $load);
    }

    //then try the category
    $fields = $this->getCategoryFields(true);
    
    if (in_array($fieldName, $fields))
    {
      return $this->_categoryObject->get($fieldName, $load);
    }
    else
    {
      //the field doesn't exist: do what the parent would do
      return parent::get($fieldName, $load);
    }
  }


  /**
   * Saves the Relationship fields, relations, and category objects
   *
   * @param   Doctrine_Connection   $conn           The connection to use
   * @param   boolean               $saveCategory   Whether to save the category object; true by default
   * @return  Relationship                          The saved object
   */
  public function save(Doctrine_Connection $conn=null, $saveCategory=true)
  {
    if ($conn === null)
    {
      $conn = Doctrine_Manager::connection();
    }
    
    //make sure category is loaded
    $this->_loadCategory();

    
    try
    {
      $conn->beginTransaction();

      // if end_date is set, is_current must be false (DISABLED FOR NOW)
      // if ($this->end_date && $this->is_current)
      // {
      //   $this->is_current = false;
      // }

      $isModified = $this->isModified();

      //save Relationship
      $ret = parent::save($conn);

      //save category
      if ($saveCategory)
      {
        if ($object = $this->getCategoryObject())
        {
          $object->relationship_id = $this->id;
          $object->save();
        }
      }

      //remove old category object
      if ($object = $this->_removedCategoryObject)
      {
        $object->delete();
        unset($this->_removedCategoryObject);
      }

      if ($isModified)
      {
        $this->updateEntitiesTimestamp();
      }

      $conn->commit();
    }
    catch (Exception $e)
    {
      $conn->rollback();
      throw $e;
    }
    
    $this->setIsSaving(false);
    
    return $ret;
  }


  public function delete(Doctrine_Connection $conn = null)
  {
    if ($conn == null) 
    {
      $conn = $this->_table->getConnection();
    }
    
    try
    {
      $conn->beginTransaction();
      foreach ($this->_table->getTemplates() as $template)
      {
        if (method_exists($template, 'onObjectDelete'))
        {
          $template->setInvoker($this);
          $template->onObjectDelete($conn);
        }
      }

      $this->updateEntitiesTimestamp();  

      $ret = parent::delete($conn);
          
      $conn->commit();
    }
    catch (Exception $e)
    {
      $conn->rollback();
      throw $e;
    }
    return $ret;
  }


  /**
   *  Magic method to allow calls to the category object
   */
  public function __call($method, $args)
  {
    foreach ($this->_table->getTemplates() as $template)
    {
      if (method_exists($template, $method))
      {
        $template->setInvoker($this);
        return call_user_func_array(array($template, $method), $args);
      }
    }
    

    $methods = $this->getCategoryMethods();

    if (in_array($method, $methods))
    {
      return call_user_func_array(array($this->getCategoryObject(), $method), $args);
    }
    else
    {
      return parent::__call($method, $args);
    }
  }


  public function postInsert($event)
  {
    RelationshipTable::createLinksFromRelationship($this);
  }
  
  
  public function postDelete($event)
  {
    RelationshipTable::deleteLinksByRelationshipId($this->id);
  }

  
  public function preUpdate($event)
  {
    $linkFields = array('entity1_id', 'entity2_id', 'category_id');
    $modifiedFields = array_keys($this->getModified());
    
    $this->_updateLinkFields = array_intersect($linkFields, $modifiedFields);
  }
  
  
  public function postUpdate($event)
  {
    if ($this->_updateLinkFields)
    {
      RelationshipTable::updateLinksFromRelationship($this);        
      $this->_updateLinkFields = false;
    }
  }


  /**
   * Overrides Doctrine_Record::fromArray() so that the category object can be hydrated too
   *
   * @param   array     $ary    Associative array of field and values to use for hydration
   * @param   boolean   $deep   Whether Doctrine relations should be hydrated too; false by default
   * @return  Entity            The hydrated Entity
   */
  public function fromArray(array $ary, $deep = true, $hydrateCategory=false)
  {
    $ret = parent::fromArray($ary, $deep);
  
    if ($hydrateCategory)
    {
      if ($object = $this->getCategoryObject())
      {
        $object->fromArray($ary, $deep);
      }
    }
    
    return $ret;
  }
  
  
  public function isModified()
  {
    if ($object = $this->getCategoryObject())
    {    
      if ($object->isModified())
      {
        return true;
      }
    }
    
    return parent::isModified();
  }

  
  /**
   * Switches this Relationship's Entity1 and Entity2.
   */  
  public function switchEntityOrder()
  {
    $e1 = $this->Entity1;
    $e2 = $this->Entity2;

    $this->Entity1 = $e2;
    $this->Entity2 = $e1;
    
    if ($this->getCategoryName() == 'Transaction')
    {
      $e1 = $this->Contact1;
      $e2 = $this->Contact2;
      
      $this->Contact1 = $e2;
      $this->Contact2 = $e1;
    }
  }

  
  public function switchEntityOrderIfNecessary()
  {
    if (!$this->Entity1 || !$this->Entity2)
    {
      throw new Exception("Can't switch Relationship entity order if Entities aren't set");
    }


    $switch = false;

    switch ($this->category_id)
    {
      case RelationshipTable::POSITION_CATEGORY:
      case RelationshipTable::EDUCATION_CATEGORY:
        if ($this->Entity1->getPrimaryExtension() == 'Org')
        {
          $switch = true;
        }
        break;
        
      case RelationshipTable::MEMBERSHIP_CATEGORY:
      case RelationshipTable::OWNERSHIP_CATEGORY:
        if ($this->Entity2->getPrimaryExtension() == 'Person')
        {
          $switch = true;
        }
        break;
    }
    
    if ($switch)
    {
      $this->switchEntityOrder();
    }
  }
  
  
  public function areSameDescriptions()
  {
    return RelationshipTable::areSameDescriptions($this);
  }
  

 
  public function getDisplayDescription($useDefault=true)
  {
    return RelationshipTable::getDisplayDescription($this, $useDefault);
  }


  
  public function setDescription1($value)
  {
    $this->_set('description1', $value);

    if ($this->Category && in_array($this->Category->name, array('Position', 'Education', 'Ownership', 'Membership', 'Donation')))
    {
      $this->description2 = $value;
    }  
  }
  
  //add a date (typically a filing date) to a relationship to update its date range
  //set $use_year to false if you want to work with exact dates
  public function updateDateRange($date, $use_year = true)
  {
      
    $date = new LsDate($date);
    
    if ($use_year)
    {
      $date->setDay('00');
      $date->setMonth('00');
    }
    
    if ($date->getYear() == '0000')
    {
      return false;
    }
    
    //start date and end date both null, make start date the date
    if (!$this->end_date && !$this->start_date)
    {
      $this->start_date = (string) $date;
      $this->end_date = (string) $date;
      return true;
    }

    $end_date = new LsDate($this->end_date);
    $start_date = new LsDate($this->start_date);
    
    $start_date_comp = LsDate::compare($date,$start_date);
    $end_date_comp = LsDate::compare($date,$end_date);
    
    //if date is the same as either start date or end date, make no changes
    if ($start_date_comp == LsDate::COMPARE_SAME || $end_date_comp === LsDate::COMPARE_SAME)
    {
      return false;
    }    
    
    //if date is before start_date, set start_date to date
    else if ($start_date_comp == LsDate::COMPARE_BEFORE)
    {
      $this->start_date = (string) $date;
      return true;
    }
    //if date is after end date, set end date equal to date
    else if ($end_date_comp == LsDate::COMPARE_AFTER)
    {
      $this->end_date = (string) $date;
      return true;
    }
    //no changes have been made
    return false;
  }

  
  public function setStartDate($str)
  {
    $this->_set('start_date', Dateable::convertForDb($str));
  }
  
  
  public function setEndDate($str)
  {
    $this->_set('end_date', Dateable::convertForDb($str));
  }  
  
  
  public function updateEntitiesTimestamp()
  {
    if (!$this->entity1_id || !$this->entity2_id)
    {
      throw new Exception("Can't update timestamps for entities; entities aren't set");
    }

    $db = Doctrine_Manager::connection();
    $sql = 'UPDATE entity e SET e.last_user_id = ?, e.updated_at = ? WHERE e.id IN (?, ?)';
    $params = array(LsVersionableListener::getUserId(), date('Y-m-d H:i:s'), $this->entity1_id , $this->entity2_id);
    $stmt = $db->execute($sql, $params);
  }
  
  public function getWatchersQuery()
  {

    
    $q = LsDoctrineQuery::create()
        ->select('u.*, count(m.id) AS mods')
        ->from('sfGuardUser u')
        ->leftJoin('u.Profile p')
        ->leftJoin('u.Modification m')
        ->where('u.id > ? and u.is_super_admin = ? and p.watching_opt_out = ?', array(2, false, false))
        ->andWhere('m.object_model = ? and m.object_id = ?', array('Relationship', $this->id));
        
      
     $q = $q->groupBy('u.id')
          ->orderBy('mods DESC');
        
    return $q;      
  }
}
