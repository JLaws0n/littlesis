<?php
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class EntityTable extends Doctrine_Table
{
  public function clear()
  {
    foreach (ExtensionDefinitionTable::$extensionNamesWithFields as $name)
    {
      $table = Doctrine::getTable($name);
      $table->clear();
    }
    
    parent::clear();
  }


  public function getRelation($alias, $recursive = true)
  {
    if ($this->hasRelation($alias))
    {
      return parent::getRelation($alias, $recursive);
    }
    
    foreach (ExtensionDefinitionTable::$extensionNamesWithFields as $extension)
    {
      if (Doctrine::getTable($extension)->hasRelation($alias))
      {
        return Doctrine::getTable($extension)->getRelation($alias, $recursive);
      }
    }
    
    return parent::getRelation($alias, $recursive);
  }


  /**
   * Returns a query for Entities having one or more extensions
   *
   * @param   mixed   $extensions   One or more extension names to limit the query
   * @return  Doctrine_Query        A query with the given constraints
   */
  static function getByExtensionQuery($extensions, $allRequired=true)
  {
    $extensions = (array) $extensions;
    
    $q = LsDoctrineQuery::create()
      ->select('e.*')
      ->from('Entity e');
 
    if ($allRequired)
    {
      $count = 1;
    
      foreach ($extensions as $extension)
      {
        $q->leftJoin('e.ExtensionRecord r' . $count)
          ->leftJoin('r' . $count . '.Definition d' . $count)
          ->addWhere('d' . $count . '.name = ?', $extension)
          ->groupBy('e.id');
          
        $count++;
      }
    }
    else
    {
      $q->leftJoin('e.ExtensionRecord r')
        ->leftJoin('r.Definition d')
        ->andWhereIn('d.name', $extensions);
    }
    
    
    foreach ($extensions as $extension)
    {
      if (in_array($extension, ExtensionDefinitionTable::$extensionNamesWithFields))
      {
        $lower = strtolower($extension);

        $q->leftJoin('e.' . $extension . ' ' . $lower);
      }
    }
    
    
    return $q;
  }


  /**
   * Returns a query for a search for multiple terms in Entity's basic text fields
   *
   * @param   Array   $terms  Array of terms to search for
   * @return  Doctrine_Query  A query for the search
   */
  static function getSimpleSearchQuery($terms, $extensions=null)
  {
    $terms = (array) $terms;

    //only search Entity text fields
    $entityFields = array('name', 'blurb', 'website');

    if ($extensions)
    {
      $q = self::getByExtensionQuery($extensions);
    }
    else
    {
      $q = LsDoctrineQuery::create()
        ->from('Entity e');
    }

    $intersectConditions = array();
    $intersectParams = array();
    
    foreach ($terms as $term)
    {
      $intersectConditions[] = 'e.name LIKE ?';
      $intersectParams[] = '%' . $term . '%';
    }
    
    $q->leftJoin('e.Alias a')
      ->select('e.*, (e.name LIKE ?) match, (' . implode(' AND ', $intersectConditions) . ') intersect', array_merge(array('%' . implode(' ', $terms) . '%'), $intersectParams))
      ->orderBy('match DESC, intersect DESC, ISNULL(e.blurb) ASC, e.updated_at DESC');

    foreach ($terms as $term)
    {
      //ignore short terms
      if (strlen($term) < 3)
      {
        continue;
      }
      
      $dql = array();
      $params = array();

      foreach ($entityFields as $field)
      {
        $dql[] = 'e.' . $field . ' LIKE ?' ;
        $params[] = '%' . $term . '%';
      }
      
      $dql[] = 'a.name LIKE ?';
      $params[] = '%' . $term . '%';
      
      $q->addWhere(implode(' OR ', $dql), $params);      
    }
        
    //make sure there's at least one term
    if (count($q->getDqlPart('where')) == 0)
    {
      $q->addWhere('1 = 0');
    }

    return $q;
  }


  /**
   * Returns a query for a search for Entity and extension fields. All fields
   * must belong to one of the given extensions.
   *
   * @param   mixed   $extensionNames   An extension name or an array of extension names
   * @param   array   $fields           An associative array of field names and their desired values
   * @return  Doctrine_Query            A query for the advanced search
   */
  static function getAdvancedSearchQuery($extensionNames = array(), Array $fields)
  {
    //build array of extension fields and the extensions they belong to
    $entityFields = array_values(Doctrine::getTable('Entity')->getFieldNames());
    $extensionFields = array();
    $extensionFieldTypes = array();
    $extensionNames = (array) $extensionNames;

    if (count($extensionNames))
    {
      $extensions = LsDoctrineQuery::create()
        ->from('ExtensionDefinition d')
        ->andWhereIn('d.name', $extensionNames)
        ->andWhere('d.has_fields = ?', true)
        ->execute();
    }
    else
    {
      $extensions = array();
    }

    foreach ($extensions as $extension)
    {
      $fieldNames = array_values(Doctrine::getTable($extension->name)->getFieldNames());

      foreach ($fieldNames as $fieldName)
      {
        if (!isset($extensionFields[$fieldName]))
        {
          $extensionFields[$fieldName] = $extension->name;
        }
      }
    }
    
  
    //build query
    $q = self::getByExtensionQuery($extensionNames);    

    foreach ($fields as $name => $value)
    {
      if (in_array($name, $entityFields))
      {
        $columnDefs = Doctrine::getTable('Entity')->getColumns();
        $type = $columnDefs[$name]['type'];
        $alias = 'e';
      }
      elseif (isset($extensionFields[$name]))
      {
        $extensionName = $extensionFields[$name];
        $columnDefs = Doctrine::getTable($extensionName)->getColumns();
        $type = $columnDefs[$name]['type'];
        $alias = strtolower($extensionName);
      }
      else
      {
        continue;
      }

      if (!is_null($value) && ($type == 'string' || $type == 'clob') && !in_array($name, array('start_date', 'end_date')))
      {
        //if field is non-null non-date string, look for substrings
        $q->andWhere($alias . '.' . $name . ' LIKE ?', '%' . $value . '%');
      }
      else
      {
        //otherwise, look for exact value
        $q->andWhere($alias . '.' . $name . ' = ?', $value);
      }
    }


    return $q;
  }



  /**
   * Merges e2 fields into e1, and returns e1
   */
  static function mergeBasic(Entity $e1, Entity $e2, $excludes=null)
  {
    //have to have the same primary extension
    if ($e1->getPrimaryExtension() != $e2->getPrimaryExtension())
    {
      throw new Exception("Can't merge persons with orgs");
    }


    //add new extensions to e1, if any
    $extensions1 = $e1->getExtensions();
    $extensions2 = $e2->getExtensions();
    
    $addExtensions = array_diff($extensions2, $extensions1);
    
    foreach ($addExtensions as $addExtension)
    {
      $e1->addExtension($addExtension);
    }


    //set values based on merge rules defined in mergeField
    $excludes = array_merge((array) $excludes, array('id', 'created_at', 'updated_at'));

    foreach ($e2->getAllData() as $field => $value)
    {
      if (!in_array($field, $excludes))
      {
        $e1->$field = self::mergeField($field, $e1->$field, $e2->$field);
      }
    }
            
    return $e1;
  }

  static function mergeAll(Entity $e1, Entity $e2)
  {
    $db = Doctrine_Manager::connection();

    try
    {
      $db->beginTransaction();


      //MERGE ENTITIES AND EXTENSIONS
      $e1 = self::mergeBasic($e1, $e2);

      
      //MERGE CONTACT INFO
      //phones are moved to e1
      foreach ($e2->Phone as $phone)
      {
        if ($e1->id)
        {
          $q = LsDoctrineQuery::create()
            ->from('Phone p')
            ->where('p.entity_id = ? AND p.number = ?', array($e1->id, $phone->number));
        
          //not if e1 already has a phone with same number
          if ($q->count())
          {
            continue;
          }
        }
        $phone->entity_id = $e1['id'];
        $phone->setMerge(true);
        $phone->save();
      }
            
      //emails are moved to e1
      foreach ($e2->Email as $email)
      {
        if ($e1->id)
        {
          $q = LsDoctrineQuery::create()
            ->from('Email e')
            ->where('e.entity_id = ? AND e.address = ?', array($e1->id, $email->address));
        
          //not if e1 already has the same email
          if ($q->count())
          {
            continue;
          }
        }
        $email->entity_id = $e1['id'];
        $email->setMerge(true);
        $email->save();
      }
      
      //addresses
      foreach ($e2->Address as $address)
      {
        if ($e1->id)
        {
          if ($address->latitude && $address->longitude)
          {
            //not if e1 already has an address with the same coords
            if (AddressTable::getByCoordsQuery($address->longitude, $address->latitude, $e1)->count())
            {
              continue;
            }
          }
        }        
        $address->entity_id = $e1['id'];
        $address->setMerge(true);
        $address->save();
      }

      //RELATIONSHIPS
      if ($e2->id)
      {
        //where e2 is first
        foreach ($e2->getRelationshipsQuery(1)->execute() as $rel)
        { 
          //don't try to merge relationships, there isn't a good way to do this automatically
        
          $rel->entity1_id = $e1['id'];
          $rel->setMerge(true);
          $rel->save();
        }
  
        //where e2 is second
        foreach ($e2->getRelationshipsQuery(2)->execute() as $rel)
        {        
          //don't try to merge relationships, there isn't a good way to do this automatically
  
          $rel->entity2_id = $e1['id'];
          $rel->setMerge(true);
          $rel->save();
        }
      }
      

      //LISTS
      //lists are moved to e1
      foreach ($e2->LsListEntity as $listEntity)
      {
        if ($e1->id)
        {
          $q = LsQuery::getByModelAndFieldsQuery('LsListEntity', array(
            'entity_id' => $e1->id,
            'list_id' => $listEntity->list_id
          ));
        
          //not if e1 is already on the list
          if ($q->count())
          {
            continue;
          }
        }
        $listEntity->entity_id = $e1;
        $listEntity->setMerge(true);
        $listEntity->save();
      }
      

      //IMAGES
      //images are moved to e1
      foreach ($e2->Image as $image)
      {
        $image->entity_id = $e1;
        $image->setMerge(true);
        $image->save();
      }


      //ALIASES
      //aliases are moved to e1
      foreach ($e2->Alias as $alias)
      {
        //not if e1 already has that alias
        if ($e1->id && $e1->hasName($alias->name, $matchContext=true, $alias->context))
        {
          continue;
        }

        $alias->entity_id = $e1;
        $alias->is_primary = false;
        $alias->setMerge(true);
        $alias->save();        
      }

      //save now so that template merges work
      $e1->last_user_id = LsVersionableListener::getUserId();
      $e1->updated_at = LsDate::getCurrentDateTime();
      $e1->setMerge(true);
      $e1->save();


      //set merged_id for e2
      $e2->merged_id = $e1['id'];


      //TEMPLATES
      foreach ($e2->_table->getTemplates() as $template)
      {
        //templates must have mergeFrom method
        if (method_exists($template, 'mergeFrom'))
        {
          $template->setInvoker($e1);        
          $template->mergeFrom($e2);
        }    
      }


      //OTHER RELATIONS      
      foreach ($e2->Child as $child)
      {
        $child->parent_id = $e1->id;
        $child->setMerge(true);
        $child->save();
      }
      
      foreach ($e2->PartyMember as $member)
      {
        $member->party_id = $e1->id;
        $member->setMerge(true);
        $member->save();
      }

      foreach ($e2->BusinessIndustry as $bi)
      {
        $q = LsDoctrineQuery::create()
          ->from('BusinessIndustry bi')
          ->where('bi.business_id = ? AND bi.industry_id = ?', array($e1->id, $bi->industry_id));
        
        if (!$q->count())
        {
          $bi->business_id = $e1->id;
          $bi->save();
        }
      }
      
      foreach ($e2->OverseenPosition as $position)
      {
        $position->boss_id = $e1->id;
        $position->save();
      }
      
      foreach ($e2->BundledDonation as $donation)
      {
        $donation->bundler_id = $e1->id;
        $donation->save();
      }
      
      foreach ($e2->LobbyFilingLobbyist as $lfl)
      {
        $lfl->lobbyist_id = $e1->id;
        $lfl->save();
      }
      
      foreach ($e2->Contact1Transaction as $t)
      {
        $t->contact1_id = $e1->id;
        $t->save();
      }

      foreach ($e2->Contact2Transaction as $t)
      {
        $t->contact2_id = $e1->id;
        $t->save();
      }
      

      //NOTES
      sfLoader::loadHelpers('Url');
      $notes = LsDoctrineQuery::create()
        ->from('Note n')
        ->where('n.entity_ids LIKE ?', '%,' . $e2->id . ',%')
        ->execute();
        
      foreach ($notes as $note)
      {
        $note->body = preg_replace('#/(person|org)/' . $e2->id . '/([^"]+)#i', '/\1/' . $e1->id . '/' . LsSlug::convertNameToSlug($e1->name), $note->body);
        $note->body_raw = preg_replace('#@entity:' . $e2->id . '(\[([^\]]+)\])?#', '@entity:' . $e1->id . '\1', $note->body_raw);
        $note->entity_ids = str_replace(',' . $e2->id . ',', ',' . $e1->id . ',', $note->entity_ids);
        $note->save();
      }

      //DONATION MATCHES
      //get matches for e2
      if ($e2->id != '')
      {
        $matches2 = Doctrine::getTable('OsEntityTransaction')->findByEntityId($e2->id);
          
        //get matches for e1
        $matches1 = Doctrine::getTable('OsEntityTransaction')->findByEntityId($e1->id);
        $matches1Sorted = array();
  
        //sort matches for e1
        foreach ($matches1 as $match1)
        {
          $matches1Sorted[$match1['cycle']][$match1['transaction_id']] = $match1;
        }
          
        //loop through e2 matches
        foreach ($matches2 as $match2)
        {
          //if e1 matched exists, update as necessary
          if ($match1 = @$matches1Sorted[$match2['cycle']][$match2['transaction_id']])
          {
            $save = false;
  
            if (!$match1['is_verified'] && $match2['is_verified'])
            {
              $match1->is_verified = true;
              $save = true;
            }
            
            if (!$match1['is_processed'] && $match2['is_processed'])
            {
              $match1->is_processed = true;
              $save = true;
            }
            
            if (!$match1['is_synced'] && $matche2['is_synced'])
            {
              $match1->is_synced = true;
              $save = true;
            }
            
            if ($save)
            {
              $match1->save();
            }
  
            $match2->delete();
          }
          else
          {
            //if e1 match doesn't exist, update the entity_id of the e2 match
            $match2->entity_id = $e1->id;
            $match2->save();
          }
        }
  
  
        //DONATION MATCHING PREPROCESS LOG
        $cycles2 = Doctrine::getTable('OsEntityPreprocess')->findByEntityId($e2->id);
        $cycles1 = OsEntityPreprocessTable::getCyclesByEntityId($e1->id);      
  
        foreach ($cycles2 as $cycle2)
        {
          //if e1 already preprocessed for this cycle, delete
          if (in_array($cycle2['cycle'], $cycles1))
          {
            $cycle2->delete();
          }
          else
          {
            //if not, update entity_id
            $cycle2->entity_id = $e1->id;
            $cycle2->save();
          }     
        }
      }

      
      //EXTERNAL KEYS
      foreach ($e2->ExternalKey as $key)
      {
        $q = LsDoctrineQuery::create()
          ->from('ExternalKey k')
          ->where('k.entity_id = ?', $e1->id)
          ->andWhere('k.domain_id = ?', $key['domain_id']);

        if (!$existingKey = $q->fetchOne())
        {
          $key->entity_id = $e1->id;
          $key->save();
        }
      }
      
      
      $db->commit();      
    }
    catch (Exception $e)
    {
      $db->rollback();
      throw $e;
    }

    $e2->clearRelated();

    return $e1;
  } 
  
  static function mergeField($fieldName, $existingValue, $newValue)
  {
    if ($newValue === null)
    {
      return $existingValue;
    }
    elseif ($existingValue === null)
    {
      return $newValue;    
    }
    elseif ($existingValue === $newValue)
    {
      return $existingValue;
    }
    

    $appendWithNewlineFields = array('summary', 'notes');
    $appendWithSpaceFields = array('name_suffix', 'name_prefix');
    $dateFields = array('start_date', 'end_date');
    $nameFields = array('name_first', 'name_middle');
    $numberFields = array('employees', 'revenue', 'endowment');

    if (in_array($fieldName, $appendWithNewlineFields))
    {
      return $existingValue . "\n\n" . $newValue;
    }
    elseif (in_array($fieldName, $appendWithSpaceFields))
    {
      return $existingValue . ' ' . $newValue;
    }
    elseif (in_array($fieldName, $dateFields))
    {
      $existingDate = new LsDate($existingValue);
      $newDate = new LsDate($newValue);

      if ($existingDate->howSpecific() > $newDate->howSpecific())
      {
        return $existingDate->format();
      }
      elseif ($existingDate->howSpecific() < $newDate->howSpecific())
      {
        return $newDate->format();
      }
      else
      {
        if ($existingDate->howSpecific() == LsDate::YEAR_SPECIFIC)
        {
          return LsDate::lessOrEqual($existingDate, $newDate) ? $existingDate : $newDate;
        }
        else
        {
          return $existingDate;
        }
      }      
    }
    elseif (in_array($fieldName, $nameFields))
    {
      return (strlen($existingValue) >= strlen($newValue) || strlen($existingValue) !== 1) ? $existingValue : $newValue;
    }
    elseif (in_array($fieldName, $numberFields))
    {
      return $existingValue == 0 ? $newValue : $existingValue;
    }
    else
    {
      return $existingValue;
    }
  }

  
  static function compare(Entity1 $e1, Entity2 $e2)
  {
    $idDiff = $e1->id - $e2->id;

    if ($idDiff > 1)
    {
      return 1;
    }
    elseif ($idDiff < 1)
    {
      return -1;
    }
    else
    {
      return 0;
    }
  }


  static function getExtensionNameByFieldName($fieldName)
  {
    foreach (ExtensionDefinitionTable::$extensionNamesWithFields as $extension)
    {
      $table = Doctrine::getTable($extension);

      if (in_array($fieldName, array_keys($table->getColumns())))
      {
        return $extension;
      }    
    }  
    
    return null;
  }


  static function relatedEntityCmp($row1, $row2)
  {
/*  THIS IS TOO SLOW TO INCLUDE NOW -- IT LETS PARENT ENTITIES SHOW UP FIRST ON LISTS OF RELATIONSHIPS

    if ($row1['entity']['parent_id'] && !$row2['entity']['parent_id'])
    {
      return -1;
    }
    elseif (!$row1['entity']['parent_id'] && $row2['entity']['parent_id'])
    {
      return 1;
    }
    elseif ($row1['entity']['parent_id'] == $row2['entity']['id'])
    {
      return -1;
    }
    elseif ($row1['entity']['id'] == $row2['entity']['parent_id'])
    {
      return 1;
    }
*/
    if (isset($row1['rels']))
    {
      $diff = count($row1['rels']) - count($row2['rels']);    
    }
    else
    {
      $diff = count($row1['Relationships']) - count($row2['Relationships']);
    }
    
    if ($diff == 0)
    {
      return 0;
    }
    elseif ($diff > 0)
    {
      return 1;
    }
    else
    {
      return -1;
    }
  }


  static function relatedEntityAmountCmp($row1, $row2)
  {
    //get row1 amount
    $row1Amount = 0;
    foreach ($row1['Relationships'] as $rel)
    {
      if (isset($rel['amount']))
      {
        $row1Amount += $rel['amount'];
      }
    }
        
    //get row2 amount
    $row2Amount = 0;
    foreach ($row2['Relationships'] as $rel)
    {
      if (isset($rel['amount']))
      {
        $row2Amount += $rel['amount'];
      }
    }

    $diff = $row1Amount - $row2Amount;

    if ($diff == 0)
    {
      return 0;
    }
    elseif ($diff > 0)
    {
      return 1;
    }
    else
    {
      return -1;
    }
  }
  
  
  static function filterEntitiesWithRelationships($ary, $categoryIds=null, $order=null, $extensions=null, $excludeExtensions=null, $orderByNum=true, $orderByAmount=false)
  {
    $ret = array();

    if ($order)
    {
      $ary = $ary[$order];
    }
    else
    {
      $ary1 = $ary[1];
      $ary2 = $ary[2];
      
      foreach ($ary2 as $catId => $catAry)
      {
        if (!isset($ary1[$catId]))
        {
          $ary1[$catId] = $catAry;
        }
        else
        {
          foreach ($catAry as $id => $entityAry)
          {
            if (!isset($ary1[$catId][$id]))
            {
              $ary1[$catId][$id] = $entityAry;
            }
            else
            {
              $ary1[$catId][$id]['rels'] = array_merge($entityAry['rels'], $ary1[$catId][$id]['rels']);
            }
          }
        }
      }
      
      $ary = $ary1;
    }


    foreach ((array) $categoryIds as $catId)
    {
      if (isset($ary[$catId]))
      {
        foreach ($ary[$catId] as $id => $entityAry)
        {
          $add = true;

          if ($extensions)
          {            
            foreach ((array) $extensions as $extension)
            {
              if (!strstr(',' . $entityAry['exts'] . ',', ',' . $extension . ','))
              {
                $add = false;
                break;
              }
            }
          }
          
          if ($add && $excludeExtensions)
          {
            foreach ((array) $excludeExtensions as $extension)
            {
              if (strstr(',' . $entityAry['exts'] . ',', ',' . $extension . ','))
              {
                $add = false;
                break;
              }
            }
          }
            
          if ($add)
          {
            if (!isset($ret[$id]))
            {
              $ret[$id] = $entityAry;
            }
            else
            {
              $ret[$id]['rels'] = array_merge($ret[$id]['rels'], $entityAry['rels']);
            }
          }
        }
      }
    }
    
    if ($orderByNum)
    {
      uasort($ret, array('EntityTable', 'relatedEntityCmp'));
      $ret = array_reverse($ret, true);
    }
    elseif ($orderByAmount)
    {
      uasort($ret, array('EntityTable', 'relatedEntityAmountCmp'));
      $ret = array_reverse($ret, true);
    }
    
    return $ret;
  }


  static function getEntitiesFromEntitiesWithRelationships($ary, $extension='Person', $requireImages=true)
  {
    $entities = array();

    foreach ($ary as $order => $categories)
    {
      foreach ($categories as $category => $entityIds)
      {
        foreach ($entityIds as $id => $entityAry)
        {
          if (!isset($entities[$id]))
          {
            if (!$requireImages || $entityAry['entity']->hasImage())
            {
              if ($extension && $entityAry['entity']->hasExtension($extension))
              {
                $entities[$id] = $entityAry['entity'];
              }
            }
          }
        }
      }
    }
    
    return $entities;
  }

  
  static function findByAlias($name, $context = null)
  {

    if ($alias = LsQuery::getByModelAndFieldsQuery('Alias',array('context' => $context,'name' => $name))->fetchOne())
    {    
      return $alias->Entity;
    }
    else
    {
      return null;
    }
  }


  static function getBySlug($slug, $extension=null, $useAliases=false)
  {
    $name = LsSlug::convertSlugToName($slug);

    if ($extension)
    {
      $q = self::getByExtensionQuery($extension);
    }
    else
    {
      $q = LsDoctrineQuery::create()
        ->from('Entity e');
    }
    
    $q->andWhere('e.name = ?', $name);
    
    if (!$entities = $q->execute())
    {
      $q = LsDoctrineQuery::create()
        ->from('Entity e')
        ->leftJoin('e.Alias a')
        ->where('a.name = ?', $name);
        
      $entities = $q->execute();
    }
    
    return $entities;
  }
  
  
  static function generateRoute($entity, $action=null, Array $params=null, $hideParams=false)
  {
    if (!is_array($entity) && !($entity instanceOf Entity))
    {
      throw new Exception("Can't get generate route; expecting Entity or array");
    }

    if ($action == 'view')
    {
      $action = null;
    }

    $paramStr = '';

    if ($params)
    {
      $params = array_diff_key($params, array_flip(array('id', 'slug', 'target', 'module', 'action')));
    
      $paramStr = http_build_query($params);
      $paramStr = !$hideParams && $paramStr ? '&' . $paramStr : null;
    }
    
    //need this so that we can use entities returned by API requests, which use primary_type instead of primary_ext
    $primary = @$entity['primary_ext'] ? $entity['primary_ext'] : $entity['primary_type'];

    if ($action)
    {
      return '@' . strtolower($primary) . '?id=' . $entity['id'] . '&slug=' . LsSlug::convertNameToSlug($entity['name']) . '&action=' . $action . $paramStr;
    }
    else
    {
      return '@' . strtolower($primary) . 'View?id=' . $entity['id'] . '&slug=' . LsSlug::convertNameToSlug($entity['name']) . $paramStr;
    }  
  }
  
  
  static function getInternalUrl($entity, $action=null, Array $params=null, $hideParams=false)
  {
    return self::generateRoute($entity, $action, $params, $hideParams);
  }
  
  
  public static function getByExtensionAndNameQuery($extensions, $str, $strength = 1)
  {
    $extensions = (array) $extensions;
    $str = trim($str);
   
    if (in_array('Org',$extensions))
    {
      $str = OrgTable::removeSuffixes($str, $exclude = array('Bancorp'));
    }
    
    if (strlen($str) < 3)
    {
      return array();
    }
    
    $q = EntityTable::getByExtensionQuery($extensions)->leftJoin('e.Alias a');
    
    $search_queries = array($str);
    
    $arr = array('\.' => ' ', '\.' => '', '\s&\s' => ' and ', '\sand\s' => ' & ',' & ' => ' ',',' =>'', '\bUS\b' => 'United States','United States\b' => 'US');
    $i = 0;
    
    while($i < count($search_queries))
    {    
      $name = $search_queries[$i];
      $i++;
      if (strlen($name) < 3)
      {
        break;
      }
      foreach ($arr as $k => $v)
      {
        $new = preg_replace('/' . $k . '/isu',$v,$name);
        if ($new != $name)
        {
          if (!in_array($new,$search_queries))
          {
            $search_queries[] = $new;
          }
        }     
      }
    }  
    
    foreach($search_queries as &$s)
    {
      if ($strength == 0)
      {
        $s = '%' . $s . '%';
      }
      else if ($strength ==1)
      {
        $s .= '%';
      }
    }
    unset($s);   
    
    $e = implode(' or ', array_fill(0,count($search_queries),'e.name like ?'));
    $a = implode(' or ', array_fill(0,count($search_queries),'a.name like ?'));
    
    $search_queries = array_merge($search_queries, $search_queries);
    
    $q->addWhere($e . ' or ' . $a, $search_queries);

    return $q;
  
  }


  static public function getLuceneIndex($fileName=null)
  {
    ProjectConfiguration::registerZend();
   
    if (file_exists($index = self::getLuceneIndexFile($fileName)))
    {
      return Zend_Search_Lucene::open($index);
    }
    else
    {
      return Zend_Search_Lucene::create($index);
    }
  }

   
  static public function getLuceneIndexFile($fileName=null)
  {
    return sfConfig::get('sf_data_dir'). '/' . ($fileName ? $fileName : sfConfig::get('app_search_lucene_index_file'));
  }  


  static function getLuceneHits($query, $limit=20)
  {
    ProjectConfiguration::registerZend();
    $index = self::getLuceneIndex();
    Zend_Search_Lucene::setResultSetLimit($limit);

    $originalQuery = $query;

    //if no ORs in query, assume all terms are ANDs
    if (!strstr($query, ' OR '))
    {
      $query = preg_replace('/\s{1,}/', ' AND ', $query);
    }

    return $index->find($query);
  }


  static function getLuceneArray($query, $limit=20)
  {
    $hits = self::getLuceneHits($query, $limit);
    $ret = array();
    
    foreach ($hits as $hit)
    {
      $ret[] = array('id' => $hit->key, 'name' => $hit->name, 'blurb' => $hit->blurb, 'primary_ext' => $hit->primary_ext);
    }
    
    return $ret;
  }


  static function updateLuceneIndex($entity, $index=null, $batchMode=false, $autoReplace=true)
  {
    if ($index === null)
    {
      $index = self::getLuceneIndex();
    }

    // don't index expired and non-activated entities
    if ($entity['is_deleted'])
    {
      return false;
    }

    // look for an existing entry
    if (!$batchMode && count($hits = $index->find('key:' . $entity['id'])))
    {
      //delete or skip
      if ($autoReplace)
      {
        foreach ($hits as $hit)
        {
          $index->delete($hit->id);
        }
      }
      else
      {
        return false;
      }
    }
   
    $doc = new Zend_Search_Lucene_Document();
   
    // store entity primary key to identify it in the search results
    $doc->addField(Zend_Search_Lucene_Field::Keyword('key', $entity['id']));
   
    // index entity fields
    $doc->addField(Zend_Search_Lucene_Field::Text('name', $entity['name'], 'utf-8'));
    $doc->addField(Zend_Search_Lucene_Field::Text('blurb', $entity['blurb'], 'utf-8'));
    $doc->addField(Zend_Search_Lucene_Field::Text('summary', $entity['summary'], 'utf-8'));
    $doc->addField(Zend_Search_Lucene_Field::UnIndexed('primary_ext', $entity['primary_ext'], 'utf-8'));

    // index aliases
    if (isset($entity['Alias']))
    {
      $aliases = array();      
      foreach ($entity['Alias'] as $alias) 
      {
        $aliases[$alias['name']] = $alias['name'];
      }            
      $aliases = join(',', array_keys($aliases));
    }
    else
    {
      $q = LsDoctrineQuery::create()
        ->select('GROUP_CONCAT(DISTINCT a.name)')
        ->from('Alias a')
        ->where('a.entity_id = ?', $entity['id'])
        ->andWhere('a.context IS NULL')
        ->groupBy('a.entity_id')
        ->setHydrationMode(Doctrine::HYDRATE_NONE);      
      list($results) = $q->execute();
      $aliases = $results[0];    
    }    
    
    $doc->addField(Zend_Search_Lucene_Field::UnStored('aliases', $aliases, 'utf-8'));
   
    // add entity to the index
    $index->addDocument($doc);
    $index->commit();

    return true;
  }
  
  
  static function getRelationshipIds($entity)
  {
    $relIds = array();

    $q = LsDoctrineQuery::create()
      ->select('r.id, r.category_id')
      ->from('Relationship r')
      ->where('r.entity1_id = ? OR r.entity2_id = ?', array($entity['id'], $entity['id']))
      ->setHydrationMode(Doctrine::HYDRATE_NONE);
      
    foreach ($q->execute() as $row)
    {
      $relIds[] = $row[0];
    }
    
    return $relIds;
  }
  
  
  static function getRecentRelationshipReferencesQuery($entity, $limit=5)
  {
    if (count($relIds = self::getRelationshipIds($entity)))
    {
      $q = LsDoctrineQuery::create()
        ->from('Reference r')
        ->where('r.object_model = ?', 'Relationship')
        ->andWhereIn('r.object_id', $relIds)
        ->orderBy('MAX(r.updated_at) DESC')
        ->groupBy('r.name, r.source')
        ->limit($limit);
    }
    else
    {
      $q = LsDoctrineQuery::create()
        ->from('Reference r')
        ->where('1=0');
    }
      
    return $q;
  }


  static function getSphinxHits($query, $page=1, $num=20, Array $listIds=null, $aliases=true, $primary_ext=null)
  {   
    $s = new LsSphinxClient();
    $s->SetServer('localhost', 3312);
    $s->SetMatchMode(SPH_MATCH_EXTENDED);
    $s->SetFieldWeights(array('name' => 3, 'aliases' => 3));
    $s->SetLimits(($page - 1) * $num, $num);

    if (is_array($listIds) && count($listIds))
    {
      $s->setFilter('list_ids', $listIds);
    }

    $query = $s->buildEntityQuery($query, $aliases, $primary_ext);

    $result = $s->Query($query, 'entities entities_delta');
    
    if ($result === false)
    {
      throw new Exception("Sphinx search failed: " . $s->getLastError());
    }
    
    return $result;
  }


  static function getSphinxPager($query, $page, $num, Array $listIds=null, $aliases=true, $primary_ext=null)
  {
    $entities = array();
    $result = self::getSphinxHits($query, $page, $num, $listIds, $aliases, $primary_ext);

    if ($result['total_found'] > 0 && isset($result['matches']))
    {
      $ids = array_keys($result['matches']);

      $db = Doctrine_Manager::connection();
      $sql = 'SELECT e.*, FIELD(e.id, ' . implode(',', $ids) . ') AS field ' . 
             'FROM entity e WHERE e.id IN (' . implode(',', $ids) . ') AND e.is_deleted = 0 ' .
             'ORDER BY field';             
      $stmt = $db->execute($sql);      
      $entities = $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    $pager = new LsDoctrinePager($entities, $page, $num);
    $pager->setNumResults($result['total_found']);
    $pager->isSubsetWithCount(true);
    
    return $pager;
  }
  
  
  static function getDeletedById($id, $hydrationMode=Doctrine::HYDRATE_RECORD)
  {
    $q = LsDoctrineQuery::create()
      ->from('Entity e')
      ->where('e.id = ? AND e.is_deleted = 1', $id)
      ->setHydrationMode($hydrationMode);
    
    return $q->fetchOne();
  }


  static function hasName($entity, $name, $matchContext=false, $context=null)
  {
    if ($name == $entity['name'])
    {
      return true;
    }
    else
    {
      $q = LsDoctrineQuery::create()
        ->from('Alias a')
        ->where('a.entity_id = ? AND a.name = ?', array($entity->id, $name));

      if ($matchContext)
      {      
        $q->addWhere('a.context = ?', $context);
      }
        
      if ($q->count())
      {
        return true;
      }
    }
    

    return false;
  }
  
  
  static function getPrimaryExtensionName($entity)
  {
    return $entity['primary_ext'] == 'Person' ? 'Person' : 'Org';
  }
  
  
  static function getProfileImageById($id)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT * FROM image where entity_id = ? AND is_featured = 1 AND is_deleted = 0 ' .
           'AND image.address_id IS NULL';
    $stmt = $db->execute($sql, array($id));
    
    return $stmt->fetch(PDO::FETCH_ASSOC);
  }
  
  
  static function hasProfileImage($entity)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT COUNT(*) FROM image where entity_id = ? AND is_featured = 1 AND is_deleted = 0';
    $stmt = $db->execute($sql, array($entity['id']));
    
    return (int) $stmt->fetch(PDO::FETCH_COLUMN) > 0; 
  }
  
  
  static function getExtensionsForDisplay($entity, $excludePrimary=false)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT DISTINCT definition_id FROM extension_record WHERE entity_id = ?';
    $stmt = $db->execute($sql, array($entity['id']));
    $definitionIds = $stmt->fetchAll(PDO::FETCH_COLUMN);
    $names = array();
        
    foreach ($definitionIds as $definitionId)
    {
      if (!$excludePrimary || $definitionId > 2)
      {
        $name = ExtensionDefinitionTable::$extensionNames[$definitionId];
        $names[ExtensionDefinitionTable::$definitionMap[$name]['display_name']] = $name;
      }
    }

    return $names;    
  }


  static function getPersonById($id)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT * FROM person WHERE entity_id = ?';
    $stmt = $db->execute($sql, array($id));

    return $stmt->fetch(PDO::FETCH_ASSOC);  
  }
  
  
  static function getAliasNamesById($id, $includePrimary=false, $excludeContext=false)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT name FROM alias WHERE entity_id = ?';
    
    if (!$includePrimary)
    {
      $sql .= ' AND is_primary = 0';
    }
    
    if ($excludeContext)
    {
      $sql .= ' AND context IS NULL';
    }
    
    $sql .=' ORDER BY is_primary DESC, name';
    
    $stmt = $db->execute($sql, array($id));
    $names = $stmt->fetchAll(PDO::FETCH_COLUMN);
    
    return $names;
  }
  
  
  static function getLsListsById($id, $includeNetworks=false)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT le.id AS le_id, le.rank, l.* FROM ls_list_entity le LEFT JOIN ls_list l ON (l.id = le.list_id) WHERE le.entity_id = ? AND le.is_deleted = 0';

    if (!$includeNetworks)
    {
      $sql .= ' AND l.is_network = 0';
    }

    $stmt = $db->execute($sql, array($id));
    
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
  }
  
  
  static function getListIdsById($id)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT list_id FROM ls_list_entity WHERE entity_id = ? AND is_deleted = 0';
    $stmt = $db->execute($sql, array($id));
    
    return $stmt->fetchAll(PDO::FETCH_COLUMN);  
  }
  
  
  static function getSimilarEntitiesQuery(Array $entity, $looseMatch=false)
  {
    return call_user_func(array($entity['primary_ext'] . 'Table', 'getSimilarQuery'), $entity, $looseMatch);  
  }
  
  
  static function loadPrimaryExtensionFields(Array $entity)
  {
    $table = strtolower($entity['primary_ext']);

    $db = Doctrine_Manager::connection();
    $sql = 'SELECT * FROM ' . $table . ' WHERE entity_id = ?';
    $stmt = $db->execute($sql, array($entity['id']));
    $person = $stmt->fetch(PDO::FETCH_ASSOC);
    
    $intersectingFields = array_intersect(array_keys($entity), array_keys($person));
    $ary = array_combine($intersectingFields, $intersectingFields);
    $person = array_diff_key($person, $ary);
    $entity = array_merge($entity, $person);
    
    return $entity;
  }
  
  
  static function hasExtension(Array $entity, $extensionName)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT COUNT(er.id) FROM extension_record er LEFT JOIN extension_definition ed ON (ed.id = er.definition_id) WHERE er.entity_id = ? AND ed.name = ?';
    $stmt = $db->execute($sql, array($entity['id'], $extensionName));
    
    return (int) $stmt->fetch(PDO::FETCH_COLUMN) > 0;
  }
  
  
  static function getAllReferencesById($id)
  {
    $db = Doctrine_Manager::connection();

    //get references for this entity
    $sql = 'SELECT r.* FROM reference r WHERE r.object_model = ? AND r.object_id = ? ORDER BY r.updated_at DESC';
    $stmt = $db->execute($sql, array('Entity', $id));
    $refs = $stmt->fetchAll(PDO::FETCH_ASSOC);

    //get relationships this entity is in
    $sql = 'SELECT DISTINCT l.relationship_id FROM link l WHERE l.entity1_id = ?';
    $stmt = $db->execute($sql, array($id));
    //$sql = 'SELECT r.id FROM relationship r WHERE (r.entity1_id = ? OR r.entity2_id = ?) AND r.is_deleted = 0';
    //$stmt = $db->execute($sql, array($id, $id));
    $relIds = $stmt->fetchAll(PDO::FETCH_COLUMN);  

    if (count($relIds))
    {
      //get references for the relationships
      $sql = 'SELECT r.* FROM reference r WHERE r.object_model = ? AND r.object_id IN (' . implode(',', $relIds) . ') ORDER BY r.updated_at DESC';
      $stmt = $db->execute($sql, array('Relationship'));    
      $refs = array_merge($refs, $stmt->fetchAll(PDO::FETCH_ASSOC));  
    }
    
    $refs = ReferenceTable::consolidate($refs);
    
    return $refs;  
  }
  
  static function getContactReferencesById($id)
  {
    $db = Doctrine_Manager::connection();

    $contact_arr = array();
    
    //get addresses this entity is in
    $sql = 'SELECT DISTINCT a.id FROM address a WHERE a.entity_id = ?';
    $stmt = $db->execute($sql, array($id));
    
    $addressIds = $stmt->fetchAll(PDO::FETCH_COLUMN);  
    if (count($addressIds))
    {
    	$contact_arr['Address'] = '(r.object_model = ? AND r.object_id IN (' . implode(',', $addressIds) . '))';
    }
    $sql = 'SELECT DISTINCT e.id FROM email e WHERE e.entity_id = ?';
    $stmt = $db->execute($sql, array($id));

    
    $emailIds = $stmt->fetchAll(PDO::FETCH_COLUMN);  
    if (count($emailIds))
		{
			$contact_arr['Email'] = '(r.object_model = ? AND r.object_id IN (' . implode(',', $emailIds) . '))';
		}
    
    $sql = 'SELECT DISTINCT p.id FROM phone p WHERE p.entity_id = ?';
    $stmt = $db->execute($sql, array($id));
    
    $phoneIds = $stmt->fetchAll(PDO::FETCH_COLUMN);  
    
    if (count($phoneIds))
		{
			$contact_arr['Phone'] = '(r.object_model = ? AND r.object_id IN (' . implode(',', $phoneIds) . '))';
		}
		$refs= array();
    //get references for the relationships
    if (count($phoneIds) || count($emailIds) || count($addressIds))
			{
			$sql = 'SELECT r.* FROM reference r WHERE ' . implode(' OR ',$contact_arr) . ' ORDER BY r.updated_at DESC'; 
			$stmt = $db->execute($sql, array_keys($contact_arr));    
			$refs = array_merge($refs, $stmt->fetchAll(PDO::FETCH_ASSOC));  
			
			$refs = ReferenceTable::consolidate($refs);
			
	  }
	  
	  return $refs;  

  }
  
  static function getMultipleById(Array $ids)
  {
    $db = Doctrine_Manager::connection();    
    $sql = 'SELECT * FROM entity WHERE id IN (' . implode(',', array_fill(0, count($ids), '?')) . ')';
    
    $stmt = $db->execute($sql, $ids);
    
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
  }
  
  
  static function getRelatedEntityIdsById($id)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT entity2_id FROM relationship WHERE entity1_id = ? AND is_deleted = 0';
    $stmt = $db->execute($sql, array($id));
    $entityIds = $stmt->fetchAll(PDO::FETCH_COLUMN);

    $sql = 'SELECT entity1_id FROM relationship WHERE entity2_id = ? AND is_deleted = 0';
    $stmt = $db->execute($sql, array($id));
    $entityIds = array_unique(array_merge($entityIds, $stmt->fetchAll(PDO::FETCH_COLUMN)));

    return $entityIds;
  }
  
  
  static function getUri($entity)
  {
    //needs to work for frontend and API
    $ext = isset($entity['primary_ext']) ? $entity['primary_ext'] : $entity['primary_type'];

    if (!$entity['id'] || !$ext || !$entity['name'])
    {
      return null;
    }

    return 'http://littlesis.org/' . strtolower($ext) . '/' . $entity['id'] . '/' . LsSlug::convertNameToSlug($entity['name']);
  }
  
  
  static function generateMetaDescription($entity)
  {
    $desc = '';
  
    if (strlen($entity['blurb']) > 15)
    {
      $desc .= $entity['blurb'] . '. ';
    }

    return $desc . "Information about " . $entity['name'] . ($entity['primary_ext'] == 'Person' ? "'s" : " and its") . " social, political, and business networks -- from board memberships to campaign contributions, old school ties to government contracts.";
  }
  

/*
  static function integrateDonations($entity)
  {
    //get incoming relationships
    $incoming = LsDoctrineQuery::create()
      ->from('Relationship r')
      ->where('r.entity2_id = ?', $entity['id'])
      ->andWhere('r.category_id = ?', RelationshipTable::DONATION_CATEGORY)
      ->execute();
    
    //organize by donor
    $donors = array();
    
    foreach ($incoming as $rel)
    {
      if (isset($donors[$rel['entity1_id']]))
      {
        $donors[$rel['entity1_id']][] = $rel;
      }
      else
      {
        $donors[$rel['entity1_id']] = array($rel);
      }
    }
    
    //consolidate for each donor
    foreach ($donors as $donor)
    {
      
    }
  }
*/

  static function cleanName($str)
  {
    $str = preg_replace('#\s{2,}#', ' ', $str);
    $str = preg_replace('#[.,]#', '', $str);
    
    return $str;
  }
  
  
  static function getNetworkIdsById($id)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT DISTINCT le.list_id FROM ls_list_entity le LEFT JOIN ls_list l ON (l.id = le.list_id) ' .
           'WHERE le.entity_id = ? AND le.is_deleted = 0 AND l.is_network = 1';
    $stmt = $db->execute($sql, array($id));

    return $stmt->fetchAll(PDO::FETCH_COLUMN);
  }
  
  
  static function getNetworksById($id)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT l.* FROM ls_list_entity le LEFT JOIN ls_list l ON (l.id = le.list_id) ' .
           'WHERE le.entity_id = ? AND le.is_deleted = 0 AND l.is_network = 1 GROUP BY l.id';
    $stmt = $db->execute($sql, array($id));

    return $stmt->fetchAll(PDO::FETCH_ASSOC);
  }


  static function getNetworkNamesById($id)
  {
    return LsDoctrineQuery::create()
      ->select('l.name')
      ->from('LsListEntity le')
      ->leftJoin('le.LsList l')
      ->where('le.entity_id = ?', $id)
      ->andWhere('le.is_deleted = 0')
      ->andWhere('l.is_network = 1')
      ->fetchAll(PDO::FETCH_COLUMN);  
  }
  
  
  static function isLocal($id)
  {
    $db = Doctrine_Manager::connection();
    $sql = 'SELECT COUNT(le.id) FROM ls_list_entity le LEFT JOIN ls_list l ON (l.id = le.list_id) ' .
           'WHERE le.entity_id = ? AND le.is_deleted = 0 AND l.is_network = 1 AND le.list_id <> ?';
    $stmt = $db->execute($sql, array($id, LsListTable::US_NETWORK_ID));

    return $stmt->fetch(PDO::FETCH_COLUMN) > 0;
  }
  
  static function getSummaryReferences($id)
  {
    $references = LsDoctrineQuery::create()
      ->from('Reference r')
      ->where('r.object_id = ? and r.object_model = ? and fields like ?',array($id,'Entity','summary'))
      ->orderBy('r.id desc')
      ->execute();
    return $references;
  }
  
  static function getName($id)
  {
    $db = LsDb::getDbConnection();
    $sql = "SELECT name FROM entity WHERE id = ?";
    $stmt = $db->execute($sql, array($id));

    return $stmt->fetch(PDO::FETCH_COLUMN);
  }

  public static function getEntitiesAndRelsForMap($entity_ids, $include_cats=array(), $exclude_cats=array())
  {
    $entities = self::getEntitiesForMap($entity_ids);
    $entity_ids = array_map(function($e) { return $e['id']; }, $entities);

    // get all rels
    $rels = self::getRelsForMap($entity_ids, $include_cats, $exclude_cats);
    
    return array("entities" => $entities, "rels" => $rels); 
  }

  public static function getRelatedEntitiesAndRelsForMap($entity_id, $num=10, $include_cats=array(), $exclude_cats=array())
  {
    // get related entity ids    
    $entities = EntityTable::getRelatedEntitiesForMap($entity_id, $num, $include_cats, $exclude_cats);
    $entity_ids = array_map(function($e) { return $e['id']; }, $entities);

    // get all rels
    $rels = self::getRelsForMap($entity_ids, $include_cats, $exclude_cats);
    
    return array("entities" => $entities, "rels" => $rels); 
  }

  public static function getAddEntityAndRelsForMap($entity_id, $entity_ids, $include_cats=array(), $exclude_cats=array())
  {
    $entity = self::getEntityForMap($entity_id);
    $rels = self::getRelsForNewMapEntity($entity_id, $entity_ids, $include_cats, $exclude_cats);
    
    return array("entities" => array($entity), "rels" => $rels); 
  }

  public static function getAddInterlocksAndRelsForMap($entity1_id, $entity2_id, $entity_ids)
  {
    $db = Doctrine_Manager::connection();
    $sql = "SELECT DISTINCT(l1.entity2_id) " . 
           "FROM link l1 LEFT JOIN link l2 ON (l1.entity2_id = l2.entity1_id) " .
           "LEFT JOIN relationship r1 ON (r1.id = l1.relationship_id) " .
           "LEFT JOIN relationship r2 ON (r2.id = l2.relationship_id) " .
           "WHERE l1.entity1_id IN (?, ?) AND l2.entity2_id IN (?, ?) " .
           "AND l1.category_id NOT IN ( " . join(",", array(RelationshipTable::DONATION_CATEGORY)) . ") " .
           "AND l2.category_id NOT IN ( " . join(",", array(RelationshipTable::DONATION_CATEGORY)) . ") " .
           "AND l1.entity2_id NOT IN ( " . join(",", $entity_ids) . ") " .
           "AND l1.entity1_id <> l2.entity2_id " . 
           "AND r1.is_deleted = 0 AND r2.is_deleted = 0";
    $stmt = $db->execute($sql, array($entity1_id, $entity2_id, $entity1_id, $entity2_id));
    $interlock_ids = $stmt->fetchAll(PDO::FETCH_COLUMN);

    if (count($interlock_ids))
    {
      $interlocks = self::getEntitiesForMap($interlock_ids);
      $rels = self::getRelsForMapBetween($interlock_ids, $entity_ids);
      return array("entities" => $interlocks, "rels" => $rels);
    }
    else
    {
      return array("entities" => array(), "rels" => array());
    }
  }

  public static function getAddRelatedEntitiesAndRelsForMap($entity_id, $num, $entity_ids, $rel_ids, $include_cats=array(), $exclude_cats=array())
  {
    if (!$entity_ids) $entity_ids = array();
    if (!$rel_ids) $rel_ids = array();
    if (!$include_cats) $include_cats = array();
    if (!$exclude_cats) $exclude_cats = array();

    $related_entities = EntityTable::getRelatedEntitiesForMap($entity_id, $num, $include_cats, $exclude_cats, $entity_ids);
    $new_entities = array();
    
    foreach ($related_entities as $entity)
    {
      if (!in_array($entity["id"], $entity_ids))
      {
        $new_entities[] = $entity;
      }
    }

    if (count($new_entities) == 0)
    {
      return array("entities" => array(), "rels" => array());
    }
    
    $new_entity_ids = array_map(function($e) { return $e['id']; }, $new_entities);
    $entity_ids = array_map(function($id) { return (int) $id; }, array_merge($entity_ids, $new_entity_ids));
    $entity_ids = array_unique($entity_ids);

    // get all new rels
    $rels = self::getRelsForMapBetween($new_entity_ids, $entity_ids, $include_cats, $exclude_cats);    
    $new_rels = array();

    foreach ($rels as $rel)
    {
      if (!in_array($rel["id"], $rel_ids))
      {
        $new_rels[] = $rel;
      }
    }

    return array("entities" => $new_entities, "rels" => $new_rels); 
  }

  public static function mapRelsFromRows($rows)
  {
    $rels = array();

    foreach ($rows as $rel)
    {
      $rels[] = NetworkMapTable::prepareRelData($rel);
    }
    
    return $rels;  
  }

  public static function getRelsForMap($entity_ids, $include_cats=array(), $exclude_cats=array(), $exclude_ids=array())
  {
    $entity1_ids = EntityTable::removeCustomIds($entity1_ids);
    $exclude_ids = EntityTable::removeCustomIds($exclude_ids);

    $db = Doctrine_Manager::connection();
    $sql = "SELECT r.id, r.entity1_id, r.entity2_id, r.category_id, r.is_current, r.end_date, r.is_deleted, " . 
           "GROUP_CONCAT(DISTINCT(rc.name) SEPARATOR ', ') AS label, " . 
           "GROUP_CONCAT(DISTINCT(r.category_id) SEPARATOR ',') AS category_ids, " . 
           "COUNT(r.id) AS num " . 
           "FROM relationship r LEFT JOIN relationship_category rc ON (rc.id = r.category_id) " . 
           "LEFT JOIN entity e1 ON (e1.id = r.entity1_id) " .
           "LEFT JOIN entity e2 ON (e2.id = r.entity2_id) " .
           "WHERE r.entity1_id IN (" . join(",", $entity_ids) . ") " . 
           "AND r.entity2_id IN (" . join(",", $entity_ids) . ") " . 
           "AND r.is_deleted = 0 " .
           "AND r.entity1_id <> r.entity2_id " .
           "AND e1.is_deleted = 0 AND e2.is_deleted = 0 " .
           (count($exclude_ids) ? "AND r.id NOT IN (" . join(",", $exclude_ids) . ") " : "") .
           (count($include_cats) ? "AND r.category_id IN (" . join(",", $include_cats) . ") " : "") .
           (count($exclude_cats) ? "AND r.category_id NOT IN (" . join(",", $exclude_cats) . ") " : "") .
           "GROUP BY LEAST(r.entity1_id, r.entity2_id), GREATEST(r.entity1_id, r.entity2_id), r.category_id";
    $stmt = $db->execute($sql);
    $rows = $stmt->fetchAll(PDO::FETCH_ASSOC);
    
    return self::mapRelsFromRows($rows);
  }

  public static function getRelsForMapBetween($entity1_ids, $entity2_ids, $include_cats=array(), $exclude_cats=array(), $entity_id=null)
  {
    $entity1_ids = EntityTable::removeCustomIds($entity1_ids);
    $entity2_ids = EntityTable::removeCustomIds($entity2_ids);

    $db = Doctrine_Manager::connection();
    $sql = "SELECT r.id, r.entity1_id, r.entity2_id, r.category_id, r.is_current, r.is_deleted, " . 
           "GROUP_CONCAT(DISTINCT(rc.name) SEPARATOR ', ') AS label, " . 
           "GROUP_CONCAT(DISTINCT(r.category_id) SEPARATOR ',') AS category_ids, " . 
           "COUNT(r.id) AS  num " . 
           "FROM link l " .
           "LEFT JOIN relationship r ON (r.id = l.relationship_id) " .
           "LEFT JOIN relationship_category rc ON (rc.id = r.category_id) " . 
           "LEFT JOIN entity e1 ON (e1.id = r.entity1_id) " .
           "LEFT JOIN entity e2 ON (e2.id = r.entity2_id) " .
           "WHERE l.entity1_id IN (" . join(",", $entity1_ids) . ") " . 
           "AND l.entity2_id IN (" . join(",", $entity2_ids) . ") " . 
           "AND l.entity1_id <> l.entity2_id " .
           ($entity_id ? "AND (r.entity1_id = ? OR r.entity2_id = ?) " : "") .
           "AND r.is_deleted = 0 " .
           "AND e1.is_deleted = 0 AND e2.is_deleted = 0 " .
           (count($include_cats) ? "AND r.category_id IN (" . join(",", $include_cats) . ") " : "") .
           (count($exclude_cats) ? "AND r.category_id NOT IN (" . join(",", $exclude_cats) . ") " : "") .
           "GROUP BY LEAST(r.entity1_id, r.entity2_id), GREATEST(r.entity1_id, r.entity2_id), r.category_id";
    $params = $entity_id ? array($entity_id, $entity_id) : array();
    $stmt = $db->execute($sql, $params);
    $rows = $stmt->fetchAll(PDO::FETCH_ASSOC);

    return self::mapRelsFromRows($rows);    
  }

  public static function getRelsForNewMapEntity($entity_id, $entity_ids=array(), $include_cats=array(), $exclude_cats=array())
  {
    if (!$entity_ids) $entity_ids = array();

    $entity_ids = EntityTable::removeCustomIds($entity_ids);

    if (!in_array($entity_id, $entity_ids))
    {
      $entity_ids[] = $entity_id;
    }

    return self::getRelsForMapBetween($entity_ids, $entity_ids, $include_cats, $exclude_cats, $entity_id);
    
    // $db = Doctrine_Manager::connection();
    // $sql = "SELECT r.id, r.entity1_id, r.entity2_id, r.category_id, r.is_current, r.is_deleted, " . 
    //        "GROUP_CONCAT(DISTINCT(rc.name) SEPARATOR ', ') AS label, " . 
    //        "GROUP_CONCAT(DISTINCT(r.category_id) SEPARATOR ',') AS category_ids, " . 
    //        "COUNT(r.id) AS  num " . 
    //        "FROM link l " .
    //        "LEFT JOIN relationship r ON (r.id = l.relationship_id) " .
    //        "LEFT JOIN relationship_category rc ON (rc.id = r.category_id) " . 
    //        "LEFT JOIN entity e1 ON (e1.id = r.entity1_id) " .
    //        "LEFT JOIN entity e2 ON (e2.id = r.entity2_id) " .
    //        "WHERE l.entity1_id IN (" . join(",", $entity_ids) . ") " . 
    //        "AND l.entity2_id IN (" . join(",", $entity_ids) . ") " . 
    //        "AND l.entity1_id <> l.entity2_id " .
    //        "AND (l.entity1_id = ? OR l.entity2_id = ?) " .
    //        "AND r.is_deleted = 0 " .
    //        "AND e1.is_deleted = 0 AND e2.is_deleted = 0 " .
    //        (count($include_cats) ? "AND r.category_id IN (" . join(",", $include_cats) . ") " : "") .
    //        (count($exclude_cats) ? "AND r.category_id NOT IN (" . join(",", $exclude_cats) . ") " : "") .
    //        "GROUP BY LEAST(r.entity1_id, r.entity2_id), GREATEST(r.entity1_id, r.entity2_id), r.category_id";
    // $stmt = $db->execute($sql, array($entity_id, $entity_id));
    // $rows = $stmt->fetchAll(PDO::FETCH_ASSOC);

    // return self::mapRelsFromRows($rows);    
  }

  public static function getEntitiesForMap($entity_ids)
  {
    return array_map(function($entity_id) { return EntityTable::getEntityForMap($entity_id); }, $entity_ids);    
  }
  
  public static function getRelatedEntitiesForMap($entity_id, $num=10, $include_cats=array(), $exclude_cats=array(), $exclude_ids=array())
  {
    $entity_ids = array_merge(array($entity_id), self::getRelatedEntityIdsForMap(
      $entity_id, 
      $num, 
      $include_cats,
      $exclude_cats,
      $exclude_ids
    ));

    return self::getEntitiesForMap($entity_ids);
  }

  public static function getRelatedEntityIdsForMap($entity_id, $num=10, $include_cats=array(), $exclude_cats=array(), $exclude_ids=array())
  {
    $exclude_ids = EntityTable::removeCustomIds($exclude_ids);

    $db = Doctrine_Manager::connection();
    $sql = "SELECT l.entity2_id, COUNT(l.id) AS num " . 
           "FROM link l " . 
           "WHERE l.entity1_id = ? AND l.entity2_id <> ? " . 
           (count($exclude_ids) ? "AND l.entity2_id NOT IN (" . join($exclude_ids, ",") . ") " : "") .
           (count($include_cats) ? "AND l.category_id IN (" . join($include_cats, ",") . ") " : "") .
           (count($exclude_cats) ? "AND l.category_id NOT IN (" . join($exclude_cats, ",") . ") " : "") . 
           "GROUP BY l.entity2_id " . 
           "ORDER BY num DESC LIMIT " . $num;
    $params = array($entity_id, $entity_id);
    $stmt = $db->execute($sql, $params);
    return $stmt->fetchAll(PDO::FETCH_COLUMN);  
  }
  
  public static function getEntityForMap($entity_id)
  {
    sfLoader::loadHelpers(array("Asset", "Url"));

    $db = Doctrine_Manager::connection();
    $sql = "SELECT e.*, i.filename " . 
           "FROM entity e LEFT JOIN image i ON (i.entity_id = e.id AND i.is_featured = 1 AND i.is_deleted = 0) " . 
           "WHERE e.id = ?";
    $params = array($entity_id);
    $stmt = $db->execute($sql, $params);      
    $entity = $stmt->fetch(PDO::FETCH_ASSOC);

    return NetworkMapTable::prepareEntityData($entity);
  }

  public static function isIntegerId($id)
  {
    return preg_match("/^\d+$/", $id) === 1;
  }

  public static function removeCustomIds($ids)
  {
    return array_filter($ids, array('EntityTable', 'isIntegerId'));
  }

  public static function railsUrl($entity, $action=null, $full=false) 
  {
    return ($full ? ("http" . (sfContext::getInstance()->getRequest()->isSecure() ? "s" : "://")) . $_SERVER['HTTP_HOST'] : "") . "/entities/" . $entity['id'] . "/" . $action;
  }

  public static function getPartnerIds($id)
  {
    $db = Doctrine_Manager::connection();
    $sql = "SELECT partner1_id, partner2_id FROM couple WHERE entity_id = ?";
    $stmt = $db->execute($sql, array($id));
    return array_map('intval', $stmt->fetch());
  }
}
