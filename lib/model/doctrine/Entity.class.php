<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class Entity extends BaseEntity
{
  /**
   * Overrides BaseEntity:setUp() to add Doctrine relations for all extensions.
   * This is primarily a convenience to allow for DQL joins between Entity and
   * extension tables.
   */
  public function setUp()
  {
		//create extension relations from static list
		foreach (ExtensionDefinitionTable::$extensionNamesWithFields as $name)
		{
			$this->hasOne($name, array('local' => 'id',
																 'foreign' => 'entity_id'));				
		}
		
		parent::setUp();		
  }


  /**
   * Protected variables used for extension management.
   */
  protected 
    $_extensionDefinitions = array(),
    $_extensionObjects = array(),
    $_extensionMethods = array(),
    $_extensionData = array(),
    $_extensionsLoaded = false,
    $_extensionsAdded = array(),
    $_extensionsRemoved = array(),
    $_isFirstSave = false,
    $_isMerge = false;


  public function setMerge($bool)
  {
    $this->_isMerge = (bool) $bool;
  }
  

  public function isMerge()
  {
    return $this->_isMerge;
  }


  /**
   * Casting an Entity as string returns its name.
   *
   * @return string
   */
  public function __toString()
  {
    return (string) $this->name;
  }
  
  
  public function getName()
  {
    return $this->rawGet('name');
  }
  
  
  /**
   * Generates internal url for any Entity action
   *
   * @return string
   */
  public function getInternalUrl($action=null, Array $params=null, $hideParams=false)
  {
    return EntityTable::generateRoute($this, $action, $params, $hideParams);
  }


  /**
   * Retrieves an Entity's profile image
   *
   * @return Image
   */
  public function getProfileImage()
  {
    return LsDoctrineQuery::create()
      ->from('Image i')
      ->where('i.entity_id = ? AND i.is_featured = ?', array($this->id, true))
      ->fetchOne();
  }


  public function hasImage()
  {
    return (bool) LsDoctrineQuery::create()  
      ->from('Image i')
      ->where('i.entity_id = ? AND i.is_featured = ?', array($this->id, true))
      ->count();
  }


  /**
   * Returns an Entity's ExtensionRecord for a particular extension
   *
   * @param   mixed   $def  An ExtensionDefinition object, id, or name
   * @return  mixed         NULL or an ExtensionRecord
   */
  public function getExtensionRecordForDefinition($def)
  {
    if (is_numeric($def))
    {
      $ret = LsDoctrineQuery::create()
        ->from('ExtensionRecord r')
        ->where('r.definition_id = ? AND r.entity_id = ?', array($def, $this->id))
        ->fetchOne();
    }
    elseif ($def instanceOf ExtensionDefinition)
    {
      $ret = LsDoctrineQuery::create()
        ->from('ExtensionRecord r')
        ->where('r.definition_id = ? AND r.entity_id = ?', array($def->id, $this->id))
        ->fetchOne();    
    }
    else
    {
      $ret = LsDoctrineQuery::create()
        ->from('ExtensionRecord r')
        ->leftJoin('r.Definition d')
        ->where('d.name = ? AND r.entity_id = ?', array($def, $this->id))
        ->fetchOne();    
    }
    
    return $ret;
  }


  /**
   * Loads extension info into variables if not already loaded
   *
   * @param bool  $force  Load even if already loaded
   */
  private function _loadExtensions($force=false)
  {
    if (!$this->_isFirstSave && $this->exists() && ($force || !$this->_extensionsLoaded))
    {
      $this->_loadExtensionDefinitions();
      $this->_loadExtensionObjects();
      $this->_extensionsLoaded = true;
    }
  }


  /**
   * Loads Entity's extension definitions to internal array
   */  
  private function _loadExtensionDefinitions()
  {
    //Entity must exist to load extension info
    if (!$this->exists())
    {
      throw new Exception('Cannot load extension definitions for new Entity');
    }


    $loadedDefs = LsDoctrineQuery::create()
      ->from('ExtensionDefinition d')
      ->leftJoin('d.ExtensionRecord r')
      ->where('r.entity_id = ?', $this->id)
      ->orderBy('d.id ASC')
      ->execute();

      
    foreach ($loadedDefs as $def)
    {
      $this->_extensionDefinitions[$def->name] = $def;
    }

      
    return $this->_extensionDefinitions;
  }
  
  
  /**
   * Returns the extension object, if any, given an extension name
   *
   * @param   mixed   $name   Class name of the extension object to retrieve
   * @return  mixed           NULL or an extension object
   */
  private function _fetchExtensionObject($name)
  {
    //Entity must exist to load extension info
    if (!$this->exists())
    {
      throw new Exception('Cannot load extension definitions for new Entity');
    }

    //use lowercase for query alias
    $lower = strtolower($name);
    
    return LsDoctrineQuery::create()
      ->from($name . ' ' . $lower)
      ->where($lower . '.entity_id = ?', $this->id)
      ->fetchOne();
  }
  
  
  /**
   * Loads all extension objects to internal array
   *
   * @return  array   Array of extension objects
   */
  private function _loadExtensionObjects()
  {
    //Entity must exist to load extension info
    if (!$this->exists())
    {
      throw new Exception('Cannot load extension objects for new Entity');
    }

    
    foreach ($this->_extensionDefinitions as $name => $definition)
    {
      //only try objects for definitions with fields
      if ($definition->has_fields)
      {
        if (!$object = $this->_fetchExtensionObject($name))
        {
          var_dump($this->id);
          throw new Exception("Couldn't load " . $name . " extension object");
        }
        
        $this->_extensionObjects[$name] = $object;
      }
    }
    
    return $this->_extensionObjects;
  }


  /**
   * Returns extension definitions, loading if needed
   *
   * @return  array   Array of extension definitions
   */
  public function getExtensionDefinitions()
  {
    $this->_loadExtensions();

    return $this->_extensionDefinitions;
  }


  /**
   * Returns extension objects, loading if needed
   *
   * @return  array   Array of extension objects
   */
  public function getExtensionObjects()
  {
    $this->_loadExtensions();
    
    return $this->_extensionObjects;
  }
  

  public function getExtensionObject($extension)
  {
    $objects = $this->getExtensionObjects();

    return isset($objects[$extension]) ? $objects[$extension] : null;
  }

   
  /**
   * Returns array of extension names
   *
   * @param   boolean   $excludePrimary   Whether to exclude Person and Org extensions
   */
  public function getExtensions($excludePrimary=false)
  {
    $this->_loadExtensions();

    $extensions = array_keys($this->getExtensionDefinitions());
    
    if ($excludePrimary)
    {
      $extensions = array_diff($extensions, array('Person', 'Org'));
    }

    return $extensions;
  }

  
  /**
   * Returns the Entity's Person or Org extension
   *
   * @return  mixed   NULL or class of primary extension
   */  
  public function getPrimaryExtension($forDisplay = false)
  {
    $extensions = $this->getExtensions();

    if (in_array('Person', $extensions))
    {
      $ret = 'Person';
    }
    elseif (in_array('Org', $extensions))
    {
      $ret = $forDisplay ? 'Organization' : 'Org';
    }
    elseif (in_array('Couple', $extensions))
    {
      $ret = 'Couple';
    }
    
    return $ret;
  }


 /*
  * Returns Person or Org extension object
  *
  * @return   mixed   NULL or the primary extension object
  */ 
  public function getPrimaryExtensionObject()
  {
    if (!$primary = $this->getPrimaryExtension())
    {
      return null;
    }
    
    $objects = $this->getExtensionObjects();
    
    return $objects[$primary];
  }

  
  /**
   * Returns extensions objects that aren't Person or Org
   *
   * @return  mixed   NULL or array of extension objects
   */
  public function getChildExtensionObjects()
  {
    $objects = $this->getExtensionObjects();

    if ($primary = $this->getPrimaryExtension())
    {
      unset($objects[$primary]);
    }
    
    return $objects;
  }
  
  
  /**
   * Returns display names of extensions in an associative array
   *
   * @param   boolean   $excludePrimary   Whether to exclude Person and Org extensions
   * @return  array                       Keys are extension class names; values are extension display names
   */
  public function getExtensionsForDisplay($excludePrimary=false)
  {
    return EntityTable::getExtensionsForDisplay($this, $excludePrimary); 
  }


  /**
   * Returns names of extensions with fields
   *
   * @return  array   Array of extension names
   */
  public function getExtensionsHavingFields()
  {
    $names = array();

    foreach ($this->getExtensionDefinitions() as $name => $definition)
    {
      if ($definition->has_fields)
      {
        $names[] = $name;
      }
    }
    
    return $names;  
  }


  /**
   * Checks if Entity has an extension of a particular name
   *
   * @param   string  $name   Name of extension to check for
   * @return  boolean         True if it has the extension, otherwise false
   */

  public function hasExtension($name)
  {
    $extensions = $this->getExtensions();
    
    return (in_array($name, $extensions));
  }
  
  
  /**
   * Adds an extension to the Entity
   *
   * @param   string  $name   Model name of the extension to add
   * @return  boolean         Whether the extension was added
   */
  public function addExtension($name)
  {
    if ($this->hasExtension($name))
    {
      return false;
    }


    //an ExtensionDefinition with the name must exist
    if (!$definition = Doctrine::getTable('ExtensionDefinition')->findOneByName($name))
    {
      throw new Exception('Extension does not exist with name ' . $name);
    }


    //make sure Entity has required parent extension
    if ($definition->tier > 1 && $definition->Parent->exists())
    {
      if (!$this->hasExtension($definition->Parent->name))
      {
        throw new Exception($name . ' extension requires ' . $definition->Parent->name . ' extension.');
      }
    }


    $this->_extensionDefinitions[$name] = $definition;

    if ($definition->has_fields)
    {
      $this->_extensionObjects[$name] = new $name;
    }
      
    $this->_extensionsAdded[$definition->name] = true;
    
    return true;
  }


  /**
   * Removes an extension from Entity
   *
   * @param   string  $name   Model name of extension to remove
   * @return  boolean         Whether an extension was removed
   */
  public function removeExtension($name)
  {
    if (!$this->hasExtension($name))
    {
      return false;
    }

    //an extensiondefinition with the name must exist
    if (!$definition = Doctrine::getTable('ExtensionDefinition')->findOneByName($name))
    {
      throw new Exception('Extension does not exist with name ' . $name);
    }


    //can't remove extension while child extensions remain
    $childDefs = $definition->Child;

    foreach ($childDefs as $childDef)
    {
      if ($this->hasExtension($childDef->name))
      {
        throw new Exception('Cannot remove ' . $name . '; ' . $childDef->name . ' requires it');
      }
    }
 
    if (isset($this->_extensionsAdded[$name]))
    {
      unset($this->_extensionsAdded[$name]);
    }
    else
    { 
      $this->_extensionsRemoved[$name] = array(
        'definition' => $this->_extensionDefinitions[$name]
      );
   
      if ($definition->has_fields)
      {
        $this->_extensionsRemoved[$name]['object'] = $this->_extensionObjects[$name];
      }
    }
 
    unset($this->_extensionDefinitions[$name]);

    if ($definition->has_fields)
    {
      unset($this->_extensionObjects[$name]);
    }
    
    return true;
  }


  /**
   * Saves Entity and (by default) adds/removes/updates extensions
   *
   * @param   Doctrine_Connection   $conn             Optional connection instance
   * @param   boolean               $saveExtensions   Whether to save extensions & their data; true by default
   * @return  Entity                                  The saved Entity
   *
   * @see Doctrine_record
   */
  public function save(Doctrine_Connection $conn=null, $saveExtensions=true, Array $networkIds=null)
  {
    if (!$this->exists())
    {
      $this->_isFirstSave = true;
    }

    if ($conn === null)
    {
      $conn = Doctrine_Manager::connection();
    }
  
    //make sure extensions are loaded
    $this->_loadExtensions();
    
    try
    {
      $conn->beginTransaction();


      if ($saveExtensions)
      {
        //run extensions' onEntitySave methods
        foreach ($this->_extensionObjects as $name => $object)
        {
          if (method_exists($object, 'onEntitySave'))
          {        
            $object->onEntitySave($this);
          }        
        }
      }


      //set primary extension
      if (!$this->primary_ext)
      {
        $this->primary_ext = $this->getPrimaryExtension();
      }


      if ($this->primary_ext == 'Person')
      {
        $this->name = PersonTable::nameizePersonName($this->name);
      }
      

      //set delta field for sphinx indexing (in rails)
      $this->delta = true;


      //save entity
      $ret = parent::save($conn);


      //add primary alias if needed
      if (!LsDoctrineQuery::create()->from('Alias a')->where('a.entity_id = ?', $this->id)->count())
      {
        $a = new Alias;
        $a->entity_id = $this->id;
        $a->name = $this->rawGet('name');
        $a->is_primary = true;
        $a->save(null, false);
      }


      if ($saveExtensions)
      {
        //save extensions
        foreach ($this->_extensionObjects as $name => $object)
        {
          //set entity_id in case it isn't set
          $object->entity_id = $this->id;
          $object->save($conn);
        }

        //save new extensions
        foreach (array_keys($this->_extensionsAdded) as $name)
        {
          $def = $this->_extensionDefinitions[$name];
          
  
          //record shouldn't already exist
          if ($this->getExtensionRecordForDefinition($def))
          {
            throw new Exception("Can't add record for extension " . $name . "; alrady exists");
          }
  

          //create record
          $record = new ExtensionRecord;
          $record->Entity = $this;
          $record->Definition = $def;
          $record->save($conn);        
        }
   
        $this->_extensionsAdded = array();


        //remove extensions
        foreach ($this->_extensionsRemoved as $name => $extAry)
        {
          $def = $extAry['definition'];
          
          if ($def->has_fields)
          {
            $object = $extAry['object'];
            $object->delete($conn);
          }
  
          if (!$record = $this->getExtensionRecordForDefinition($def))
          {        
            throw new Exception("Can't remove record for extension " . $name . "; doesn't exist");
          }
  
          $record->delete($conn);
        }    
      }      

      //if creating, add entity to specified networks, otherwise, default network
      if ($this->_isFirstSave)
      {
        if ($networkIds)
        {
          foreach ($networkIds as $networkId)
          {
            $le = new LsListEntity;
            $le->list_id = $networkId;
            $le->entity_id = $this->id;
            $le->save(null, true, false); //prevents it from trying to update the entity updated_at and last_user_id fields
          }
        }
        else
        {
          if (sfContext::hasInstance() && $user = sfContext::getInstance()->getUser()->getGuardUser())
          {
            $networkId = $user->Profile->home_network_id;
          }
          else
          {
            $networkId = LsListTable::US_NETWORK_ID;
          }
          
          $le = new LsListEntity;
          $le->list_id = $networkId;
          $le->entity_id = $this->id;
          $le->save(null, true, false); //prevents it from trying to update the entity updated_at and last_user_id fields
        }
      }

      $conn->commit();
    }
    catch (Exception $e)
    {
      $conn->rollback();
      throw $e;
    }
    
    $this->_isFirstSave = false;
    
    return $ret;
  }


  public function delete(Doctrine_Connection $conn = null)
  {
    if ($conn == null) 
    {
      $conn = $this->_table->getConnection();
    }

    
    try
    {
      $conn->beginTransaction();
  

      foreach ($this->_table->getTemplates() as $template)
      {
        if (method_exists($template, 'onObjectDelete'))
        {
          $template->setInvoker($this);
          $template->onObjectDelete($conn);
        }
      }
  
      
      //gotta soft delete Relationships, they won't cascade due to entity's SoftDelete
      $q = LsDoctrineQuery::create()
        ->delete('Relationship r')
        ->where('r.entity1_id = ? OR r.entity2_id = ?', array($this->id, $this->id))
        ->execute();
        

      //same with LsListEntity records
      $q = LsDoctrineQuery::create()
        ->delete('LsListEntity le')
        ->where('le.entity_id = ?', $this->id)
        ->execute();
  

      $ret = parent::delete($conn);
      
      $conn->commit();
    }
    catch (Exception $e)
    {
      $conn->rollback();
      throw $e;
    }

    return $ret;      
  }



  /**
   * Returns associative array of Entity & extension fields and their values
   *
   * @param   boolean   $includeRelations   Whether to include Doctrine relations; false by default
   * @return  array                         Keys are field names; values are field values
   */
  public function getAllData($includeRelations=false)
  {
    $data = $this->toArray($includeRelations);
    
    foreach ($this->getExtensionData($includeRelations) as $field => $value)
    {
      $data[$field] = $value;
    }
    
    return $data;
  }


  /**
   * Returns associative array of extension fields and data
   *
   * @param   boolean   $includeRelations   Whether to include Doctrine relations; false by default
   * @return  array                         Keys are field names; values are field values
   */
  public function getExtensionData($includeRelations=false)
  {
    $data = array();

    foreach ($this->getExtensionObjects() as $object)
    {
      foreach ($object->toArray() as $field => $value)
      {
        if (!in_array($field, array('id', 'entity_id')))
        {
          $data[$field] = $value;
        }        
      }      
    }
    
    return $data;  
  }


  /**
   * Returns array of Entity and extension field names
   *
   * @param   boolean   $includeRelations   Whether to include Doctrine relations; false by default
   * @return  array                         Array of extension field names
   */
  public function getAllFields($includeRelations=false)
  {
    $extFields = array_keys($this->getExtensionFields($includeRelations));
    
    return array_unique(array_merge($extFields, array_keys($this->toArray($includeRelations))));
  }


  /**
   * Returns array of modified Entity and extension field names
   *
   * @return  array   Array of modified field names
   */
  public function getAllModifiedFields()
  {
    $allowedFields = array_diff($this->getAllFields(), array('id', 'is_deleted', 'last_user_id'));
    
    
    $entityFields = array_keys($this->getModified());
    $extensionFields = array();
    
    foreach ($this->getExtensionObjects() as $object)
    {
      $extensionFields = array_merge($extensionFields, array_keys($object->getModified()));
    }
    
    
    $removedFields = array();

    foreach ($this->_extensionsRemoved as $name => $ary)
    {
      if (isset($ary['object']) && $object = $ary['object'])
      {
        $removedFields = array_merge($removedFields, array_keys($object->getData()));
      }
    }
    
    $removedFields = array_diff($removedFields, array('id', 'entity_id'));

    
    $fields = array_intersect($allowedFields, array_merge($entityFields, $extensionFields));
    $fields = array_merge($fields, $removedFields);
    array_unique($fields);
    
    return $fields;
  }


  public function getAllModified()
  {
    $allowedFields = array_flip(array_diff($this->getAllFields(), array('id', 'is_deleted')));
    
    $entityModified = $this->getModified();
    $extensionModified = array();
    
    foreach ($this->getExtensionObjects() as $object)
    {
      $extensionModified = array_merge($extensionModified, $object->getModified());
    }
    
    
    $removedModified = array();

    foreach ($this->_extensionsRemoved as $name => $ary)
    {
      if (isset($ary['object']) && $object = $ary['object'])
      {
        $blankObject = new $name;
        $removedModified = array_merge($removedModified, $blankObject->toArray());
      }
    }
    
    unset($removedModified['id']);
    unset($removedModified['entity_id']);
    
    
    $modified = array_intersect_key(array_merge($entityModified, $extensionModified), $allowedFields);    
    $modified = array_merge($modified, $removedModified);
    array_unique($modified);
    
    return $modified;
  }


  public function getOldData()
  {
    $data = LsVersionable::getOldRecordData($this);

    foreach ($this->getExtensionObjects() as $object)
    {
      $extData = LsVersionable::getOldRecordData($object);
      
      $data = array_merge($data, $extData);
    }

    foreach ($this->_extensionsRemoved as $name => $ary)
    {
      if (isset($ary['object']))
      {
        $extData = LsVersionable::getOldRecordData($ary['object']);
        
        $data = array_merge($data, $extData);
      }
    }
    
    return $data;
  }
  
  
  public function getOldRecord()
  {
    $old = new Entity;
    
    foreach ($this->getExtensions() as $extension)
    {
      $old->addExtension($extension);
    }
    
    foreach ($this->_extensionsRemoved as $name => $object)
    {
      $old->addExtension($name);    
    }
    
    $old->fromArray($this->getOldData(), null, true);
    
    return $old;  
  }


  public function getRelationAliasByFieldName($fieldName)
  {
    $object = $this->getInvoker();
    $table = $object->getTable();
    
    foreach ($table->getRelations() as $name => $relation)
    {
      if ($relation->getLocalFieldName() == $fieldName)
      {
        return $name;
      }
    }
    
    foreach ($this->_extensionObjects as $name => $object)
    {
      if ($name = LsVersionable::getRelationAliasByRecordAndFieldName($object, $fieldName))
      {
        return $name;
      }
    }
    
    return null;
  }


  /**
   * Returns array of extension field names
   *
   * @param   boolean   $includeRelations   Whether to include Doctrine relations; false by default
   * @return  array                         Array of extension field names
   */
  public function getExtensionFields($includeRelations=false)
  {
    $fields = array();

    foreach ($this->getExtensionsHavingFields() as $extension)
    {
      $table = Doctrine::getTable($extension);
      
      foreach ($table->getFieldNames() as $fieldName)
      {
        $fields[$fieldName][] = $extension;
      }
      
      if ($includeRelations)
      {
        foreach (array_keys($table->getRelations()) as $fieldName)
        {
          $fields[$fieldName][] = $extension;
        }
      }
    }
    
    foreach (array('id', 'entity_id', 'Entity') as $fieldName)
    {
      unset($fields[$fieldName]);
    }
    
    return $fields;
  }


  /**
   * Returns array of extension method names
   *
   * @return  array   Array of extension method names
   */
  public function getExtensionMethods()
  {
    $ret = array();

    foreach ($this->getExtensions() as $extension)
    {
      $methods = (array) get_class_methods($extension);

      foreach ($methods as $method)
      {
        $ret[$method] = $extension;
      }
    }
    
    return $ret;
  }


  /**
   * Identical to Doctrine_Relation::set(), created to allow an Entity's name field to be set directly
   *
   * @see Doctrine_Record
   */
  public function setEntityField($fieldName, $value)
  {
    return parent::set($fieldName, $value, false);
  }


  /**
   * Sets Entity field, or an extension field, to a given value
   *
   * @see Doctrine_Record
   */  
  public function set($fieldName, $value, $load=true)
  {
    //try Entity first, unless it's the 'name' field
    $entityFields = array_merge(array_keys($this->_data), array_keys($this->getTable()->getRelations()));

    if (in_array($fieldName, $entityFields) && $fieldName != 'name')
    {
      return parent::set($fieldName, $value, $load);
    }


    //then try the extensions
    $fields = $this->getExtensionFields(true);

    if (array_key_exists($fieldName, $fields))
    {
      foreach ($fields[$fieldName] as $extension)
      {
        $this->_extensionObjects[$extension]->set($fieldName, $value, $load);
      }
    }
    else
    {
      //the field doesn't exist: do what the parent would do
      parent::set($fieldName, $value, $load);
    }
    
    return $this;
  }


  /**
   * Returns Entity field value, or an extension field value
   *
   * @see Doctrine_Record
   */
  public function get($fieldName, $load=true)
  {
    //try Entity first
    $entityFields = array_merge(
      array_keys($this->_data), 
      array_keys($this->_table->getRelations())
    );

    if (in_array($fieldName, $entityFields))
    {
      return parent::get($fieldName, $load);
    }


    //then try the extensions
    $fields = $this->getExtensionFields(true);
    
    if (array_key_exists($fieldName, $fields))
    {
      return $this->_extensionObjects[$fields[$fieldName][0]]->get($fieldName, $load);
    }
    else
    {
      //the field doesn't exist: do what the parent would do
      return parent::get($fieldName, $load);
    }    
  }

 
  /**
   * Magic method to allow calls to extension methods
   */ 
  public function __call($method, $args)
  {
    $methods = $this->getExtensionMethods();
    
    if (isset($methods[$method]))
    {
      return call_user_func_array(array($this->_extensionObjects[$methods[$method]], $method), $args);
    }
    else
    {
      return parent::__call($method, $args);
    }
  }


  /**
   * Overrides Doctrine_Record::fromArray() so that extension objects can be hydrated too
   *
   * @param   array     $ary    Associative array of field and values to use for hydration
   * @param   boolean   $deep   Whether Doctrine relations should be hydrated too; false by default
   * @return  Entity            The hydrated Entity
   */
  public function fromArray(array $ary, $deep = true, $hydrateExtensions=false)
  {
    $ret = parent::fromArray($ary, $deep);
  

    if ($hydrateExtensions)
    {  
      $objects = $this->getExtensionObjects();
      
      foreach ($objects as $object)
      {
        $object->fromArray($ary, $deep);
      }  
    }
    
    return $ret;
  }
  
  
  public function isModified()
  {
    foreach ($this->getExtensionObjects() as $object)
    {
      if ($object->isModified())
      {
        return true;
      }
    }
    
    return parent::isModified();
  }
  
  
  /**
   * Return ids of RelationshipCategories that the Entity's Relationships can have,
   * based on the Entity's extensions.
   *
   * @return  array   Array of RelationshipCategory ids
   */  
  public function getAllowedCategoryIds()
  {
    $ret = array();
    $extensions = $this->getExtensions();
    $categories = Doctrine::getTable('RelationshipCategory')->findAll();

    foreach ($categories as $category)
    {
      $req1 = $category->entity1_requirements;
      $req2 = $category->entity2_requirements;
      
      if (!$req1 && !$req2)
      {
        $ret[$category->id] = null;
      }
      elseif ($req1 && !$req2 && !in_array($req1, $extensions))
      {
        $ret[$category->id] = 2;
      }
      elseif (!$req1 && $req2 && !in_array($req2, $extensions))
      {
        $ret[$category->id] = 1;
      }
    }
    
    return $ret;
  }

  /**
   * Returns a query for all of an Entity's Relationships, limited by various parameters
   *
   * @param   integer   $order        1 or 2 to limit to Relationships where the Entity is entity1_id or entity2_id
   * @param   mixed     $categoryIds  A single category_id or array of category_ids to limit the query to
   * @param   mixed     $description  A description to limit the query to
   * @param   string    $startDate    Limits Relationships to those ending on or after a date
   * @param   string    $endDate      Limits Relationships to those starting on or before a date
   *
   * @return  Doctrine_Query          A query with the given constraints
   */
  
  public function getRelationshipsQuery($order=null, $categoryIds=null, $description=null, $startDate=null, $endDate=null, $orderBy='date')
  {
    $q = LsDoctrineQuery::create()
      ->from('Relationship r');
      
    if ($order)
    {
      $q->where('r.entity' . $order . '_id = ?', $this->id);
      
      if ($description)
      {
        $relatedOrder = (($order + 1) % 2) + 1;
        $q->addWhere('r.description' . $relatedOrder . ' = ?', $description);
      }
    }
    else
    {
      $q->where('r.entity1_id = ? OR r.entity2_id = ?', array($this->id, $this->id));

      if ($description)
      {
        $q->addWhere('(r.entity1_id = ? AND r.description2 = ?) OR (r.entity2_id = ? AND r.description1 = ?)', array($this->id, $description, $this->id, $description));
      }
    }
    
    if ($categoryIds) { $q->andWhereIn('r.category_id', (array) $categoryIds); }

    LsQuery::addDates($q, $startDate, $endDate);


    switch ($orderBy)
    {
      default:
      case 'date':
        $q->orderBy('r.start_date DESC, r.end_date DESC');
        break;

      case 'entity':
        $q->leftJoin('r.Entity1 e ON (e.id IN (r.entity1_id, r.entity2_id) AND e.id <> ?)', $this->id)
          ->leftJoin('e.Relationship r2 ON (e.id IN (r2.entity1_id, r2.entity2_id) AND ? IN (r2.entity1_id, r2.entity2_id))', $this->id)
          ->groupBy('r.id')
          ->select('r.*, COUNT(r2.id) AS num');
        break;

      case 'category':
        $q->orderBy('r.category_id ASC');
        break;
    }

    return $q;
  }

  /**
   * Returns a query for all other Entities this Entity has a Relationship with, limited by various parameters
   *
   * @param   mixed     $extensions   One or more extensions that the related Entity must have
   * @param   mixed     $categoryIds  A single category_id or array of category_ids to limit the query to
   * @param   mixed     $description  A description to limit the query to
   * @param   string    $startDate    Limits Relationships to those ending on or after a date
   * @param   string    $endDate      Limits Relationships to those starting on or before a date
   *
   * @return  Doctrine_Query          A query with the given constraints
   */
  public function getRelatedEntitiesQuery($extensions=null, $categoryIds=null, $description=null, $startDate=null, $endDate=null, $orderByNum=true, $order=null)
  {
    $q = LsDoctrineQuery::create()
      ->from('Entity e')
      ->addWhere('e.id <> ?' , $this->id)
      ->groupBy('e.id');

    if ($order == 2)
    {
      $q->leftJoin('e.Relationship r ON (e.id = r.entity1_id AND r.entity2_id = ?)', $this->id);
    }
    elseif ($order == 1)
    {
      $q->leftJoin('e.Relationship r ON (e.id = r.entity2_id AND r.entity1_id = ?)', $this->id);
    }
    else
    {
      $q->leftJoin('e.Relationship r1 ON (e.id = r1.entity1_id AND r1.entity2_id = ?)', $this->id)
        ->leftJoin('e.Relationship r2 ON (e.id = r2.entity2_id AND r2.entity1_id = ?)', $this->id)
        ->where('r1.entity1_id IS NOT NULL OR r2.entity2_id IS NOT NULL');
    }
      
    if ($orderByNum)
    {
      if ($order)
      {
        $q->select('e.*, COUNT(r.id) AS num');
      }
      else
      {
        $q->select('e.*, (COUNT(DISTINCT r1.id) + COUNT(DISTINCT r2.id)) AS num');
      }

      $q->orderBy('num DESC');
    }
    
    if ($extensions)
    {
      LsQuery::addExtensionRequirement($q, $extensions);
    }
 
    if ($categoryIds)
    { 
      $inStr = implode(',', (array) $categoryIds);

      if ($order)
      {
        $q->andWhereIn('r.category_id', (array) $categoryIds);     
      }
      else
      {
        $q->andWhere('r1.category_id', (array) $categoryIds); 
      }
    }
    
    if ($description)
    { 
      if ($order == 2)
      {
        $q->addWhere('r.description1 = ?', $description);      
      }
      elseif ($order == 1)
      {
        $q->addWhere('r.description2 = ?', $description);            
      }
      else
      {
        $q->addWhere('r1.description1 = ? OR r2.description2 = ?', array($description, $description));
      }
    }

    //LsQuery::addDates($q, $startDate, $endDate);

    return $q;
  }


  public function getEntitiesWithRelationships($categoryIds=null, $description=null, $orderByNum=true, $order=null)
  {
    $results = array(1 => array(), 2 => array());

    $q = LsDoctrineQuery::create()
      ->select('r.*, e1.*, e2.*, GROUP_CONCAT(DISTINCT ed1.name) exts1, GROUP_CONCAT(DISTINCT ed2.name) exts2')
      ->from('Relationship r')
      ->leftJoin('r.Entity1 e1')
      ->leftJoin('r.Entity2 e2')
      ->leftJoin('e1.ExtensionRecord er1')
      ->leftJoin('er1.Definition ed1')
      ->leftJoin('e2.ExtensionRecord er2')
      ->leftJoin('er2.Definition ed2')
      ->groupBy('r.id');

    if ($order == 1)
    {
      $q->where('r.entity1_id = ?', $this->id);
    }
    elseif ($order == 2)
    {
      $q->where('r.entity2_id = ?', $this->id);
    }
    else
    {
      $q->where('r.entity1_id = ? OR r.entity2_id = ?', array($this->id, $this->id));
    }

    if ($categoryIds)
    { 
      $categoryIds = (array) $categoryIds;

      if (count($categoryIds) == 1)
      {
        $q->andWhere('r.category_id = ?', $categoryIds[0]);
      }
      else
      {
        $q->andWhereIn('r.category_id', (array) $categoryIds);
      }
    }

    if ($description)
    { 
      if ($order == 2)
      {
        $q->addWhere('r.description1 = ?', $description);      
      }
      elseif ($order == 1)
      {
        $q->addWhere('r.description2 = ?', $description);            
      }
      else
      {
        $q->addWhere('(r.entity1_id = ? AND r.description2 = ?) OR (r.entity2_id = ? AND r.description1 = ?)', array($this->id, $description, $this->id, $description));
      }
    }

    $rows = $q->fetchArray();

    foreach ($rows as $row)
    {
      $order = ($row['entity1_id'] == $this->id) ? 1 : 2;
      $related = ($row['entity1_id'] == $this->id) ? $row['Entity2'] : $row['Entity1'];
      $exts = ($row['entity1_id'] == $this->id) ? $row['exts2'] : $row['exts1'];
      $catId = $row['category_id'];

      if (!isset($results[$order][$catId]))
      {
        $results[$order][$catId] = array();
      }

      if (!isset($results[$order][$catId][$related['id']]))
      {
        $results[$order][$catId][$related['id']] = array('entity' => $related, 'exts' => $exts, 'rels' => array($row));
      }
      else
      {
        $results[$order][$catId][$related['id']]['rels'][] = $row;
      }
    }

    foreach ($results[1] as $catId => $catResults)
    {
      uasort($catResults, array('EntityTable', 'relatedEntityCmp'));
      $results[1][$catId] = array_reverse($catResults, true);
    }

    foreach ($results[2] as $catId => $catResults)
    {
      uasort($catResults, array('EntityTable', 'relatedEntityCmp'));
      $results[2][$catId] = array_reverse($catResults, true);
    }
  
    
    return $results;
  }
  
    
  /**
   * Returns a query for all relationships between this Entity and another given Entity
   *
   * @param   Entity    $entity       The Entity to query for relationships with
   * @param   mixed     $categoryIds  A single category_id or array of category_ids to limit the query to
   * @param   mixed     $description  A description to limit the query to
   * @param   string    $startDate    Limits Relationships to those ending on or after a date
   * @param   string    $endDate      Limits Relationships to those starting on or before a date
   *
   * @return  Doctrine_Query          A query with the given constraints
   */   
  public function getRelationshipsWithQuery(Entity $entity, $categoryIds=null, $description=null, $startDate=null, $endDate=null, $order=null)
  {
    $q = LsDoctrineQuery::create()
      ->select('r.*')
      ->from('Relationship r')
      ->leftJoin('r.Category c')
      ->leftJoin('r.Entity1 e1')
      ->leftJoin('r.Entity2 e2')
      ->orderBy('r.start_date DESC, r.end_date DESC');

    if ($order == 1)
    {
      $q->addWhere('r.entity1_id = ? AND r.entity2_id = ?', array($this->id, $entity->id));
    }
    elseif ($order == 2)
    {
      $q->addWhere('r.entity1_id = ? AND r.entity2_id = ?', array($entity->id, $this->id));
    }
    else
    {
      $q->addWhere(
       '(r.entity1_id = ? AND r.entity2_id = ?) OR (r.entity1_id = ? AND r.entity2_id = ?)',
       array($this->id, $entity->id, $entity->id, $this->id)
      );    
    }
    
    if ($categoryIds)
    { 
      $q->andWhereIn('r.category_id', (array) $categoryIds);
    }
    
    if ($description)
    {
      if ($order == 1)
      {
        $q->addWhere('r.description2 = ?', $description);
      }
      elseif ($order == 2)
      {
        $q->addWhere('r.description1 = ?', $description);      
      }
      else
      {
        $q->addWhere('(r.entity1_id = ? AND r.description2 = ?) OR (r.entity2_id = ? AND r.description1 = ?)', array($this->id, $description, $this->id, $description));
      }
    }

    LsQuery::addDates($q, $startDate, $endDate);
    
    return $q;
  }
  
  
  /**
   * Returns all Entities this Entity made a donation to, limited by various parameters
   *
   * @param   mixed     $extensions   One or more extensions that the related Entity must have
   * @param   mixed     $description  A description to limit the query to
   * @param   string    $startDate    Limits Relationships to those ending on or after a date
   * @param   string    $endDate      Limits Relationships to those starting on or before a date
   *
   * @return  Doctrine_Query          A query with the given constraints
   */     
  public function getDonationRecipientsQuery($extensions=null, $description=null, $startDate=null, $endDate=null)
  {
    $q = $this->getRelatedEntitiesQuery(
      $extensions,
      RelationshipTable::DONATION_CATEGORY,
      $description,
      $startDate,
      $endDate,
      false
    );
    
    $q->select('e.*, SUM(r2.amount) AS total')
      ->orderBy('total DESC');
      
    return $q;
  }


  /**
   * Returns a query for Entities two degrees of separation (via Relationships) from this Entity.
   * In the param definitions below, the following terms are used:
   *
   * Entity0:         This Entity
   * Entity1:         The entity with a relationship to this Entity0 (one degree of separation)
   * Entity2:         The entity with a relationship to Entity1 (two degrees of separation)
   * Relationship1:   The Relationship between Entity and Entity1
   * Relationship2:   The Relationship between Entity1 and Entity2
   * 
   * This query is looking for Entity2s that match this pattern:
   * Entity0 <---(Relationship1)---> Entity1 <---(Relationship2)---> Entity2
   *
   * @param   integer   $order1         Order of Entity1 in Relationship1; can be 1, 2, or NULL
   * @param   integer   $order2         Order of Entity2 in Relationship2; can be 1, 2, or NULL
   * @param   mixed     $categoryIds1   Limits Relationship1 to one or more category_ids
   * @param   mixed     $categoryIds2   Limits Relationship2 to one or more category_ids
   * @param   mixed     $description1   A description to limit Relationship1
   * @param   mixed     $description2   A description to limit Relationship2
   * @param   mixed     $extensions1    Limits Entity1 to one or more extension names
   * @param   mixed     $extensions2    Limits Entity2 to one or more extension names
   * @param   boolean   $concurrent     Whether Relationship1 and Relationship2 must overlap in time; false by default
   * @param   boolean   $orderByNum     Whether to order queried Entity2s by number of common Entity1s; true by default
   *
   * @return  Doctrine_Query            A query with the given constraints
   */
  public function getSecondDegreeEntitiesQuery(
    $order1=null,
    $order2=null,
    $categoryIds1=null, 
    $categoryIds2=null,
    $description1=null,
    $description2=null,
    $extensions1=null, 
    $extensions2=null, 
    $concurrent=false, 
    $orderByNum=true
  )
  {
    $q = LsDoctrineQuery::create();
    
    if ($orderByNum)
    {
      $q->select('e2.*, COUNT(DISTINCT e1.id) num, GROUP_CONCAT(DISTINCT e1.id) as first_degree_ids')
      ->orderBy('num DESC');
    }
    else
    {
      $q->select('e2.*, GROUP_CONCAT(DISTINCT e1.id) as first_degree_ids');    
    }

    $q->from('Entity e2');
    
    if ($order2)
    {
      $q->innerJoin('e2.Relationship r2 ON r2.entity' . $order2 . '_id = e2.id');
      $q->innerJoin('r2.Entity1 e1 ON r2.entity' . (3 - $order2) . '_id = e1.id');
    }
    else
    {
      $q->innerJoin('e2.Relationship r2 ON e2.id IN (r2.entity1_id, r2.entitiy2_id)');
      $q->innerJoin('r2.Entity1 e1 ON e1.id IN (r2.entity1_id, r2.entitiy2_id)');
    }
    
    if ($order1)
    {
      $q->innerJoin('e1.Relationship r1 ON r1.entity' . $order1 . '_id = e1.id')
        ->addWhere('r1.entity' . (3 - $order1) . '_id = ?', $this->id);
    }
    else
    {
      $q->innerJoin('e1.Relationship r1 ON e1.id IN (r1.entity1_id, r1.entitiy2_id)')
        ->addWhere('r1.entity1_id = ? OR r1.entity2_id = ?', array($this->id, $this->id));
    }
        
    $q->addWhere('e2.id <> ?', $this->id)
      ->groupBy('e2.id');
      
    if ($categoryIds1) { $q->andWhereIn('r1.category_id', (array) $categoryIds1); }
    if ($categoryIds2) { $q->andWhereIn('r2.category_id', (array) $categoryIds2); }

    if ($extensions1)
    {
      LsQuery::addExtensionRequirement($q, $extensions1, 'e1');    
    }
    
    if ($extensions2)
    {
      LsQuery::addExtensionRequirement($q, $extensions2, 'e2', '2');
    }

    if ($concurrent)
    {
      LsQuery::addConcurrence($q);
    }
      
    return $q;
  }


  /**
   * Returns query for person Entities with positions the same organization as this Entity
   * See getSecondDegreeEntitiesQuery() for param info.
   *
   * @return  Doctrine_Query  A query with the given constraints
   */ 
  public function getNetworkPersonsQuery($personExtensions=null, $orgExtensions=null, $concurrent=false)
  {
    $q = $this->getSecondDegreeEntitiesQuery(
      2,
      1,
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      null,
      null,
      $orgExtensions,
      $personExtensions,
      $concurrent,
      true
    );

    return $q;
  }


  /**
   * Returns query for org Entities with same persons in positions as this Entity
   * See getSecondDegreeEntitiesQuery() for param info.
   *
   * @return  Doctrine_Query  A query with the given constraints
   */ 
  public function getNetworkOrgsQuery($orgExtensions=null, $personExtensions=null, $concurrent=false)
  {
    $q = $this->getSecondDegreeEntitiesQuery(
      1,
      2,
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      null,
      null,
      $personExtensions,
      $orgExtensions,
      $concurrent,
      true
    );

    return $q;
  }
  
  
  /**
   * Returns query for Entities that made donations to the same Entities as this one
   *
   * @return  Doctrine_Query  A query with the given constraints
   */ 
  public function getSimilarDonorsQuery($donorExtensions=null, $recipientExtensions=null, $concurrent=false)
  {
    $q = $this->getSecondDegreeEntitiesQuery(
      2,
      1,
      array(RelationshipTable::DONATION_CATEGORY),
      array(RelationshipTable::DONATION_CATEGORY),
      null,
      null,
      $recipientExtensions,
      $donorExtensions,
      $concurrent,
      true
    );

    return $q;
  }
  

  /**
   * Returns query for Entities that persons with positions in this Org have given to
   *
   * @return  Doctrine_Query  A query with the given constraints
   */ 
  public function getPersonRecipientsQuery($recipientExtensions=null, $personExtensions=null, $concurrent=false)
  {
    $q = $this->getSecondDegreeEntitiesQuery(
      1,
      2,
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      array(RelationshipTable::DONATION_CATEGORY),
      null,
      null,
      $personExtensions,
      $recipientExtensions,
      $concurrent,
      true
    );

    return $q;
  }  


  /**
   * Returns query for entities that donors to this entity have also given to
   *
   * @return  Doctrine_Query  A query with the given constraints
   */ 
  public function getDonorRecipientsQuery($recipientExtensions=null, $donorExtensions=null, $concurrent=false)
  {
    $q = $this->getSecondDegreeEntitiesQuery(
      1,
      2,
      array(RelationshipTable::DONATION_CATEGORY),
      array(RelationshipTable::DONATION_CATEGORY),
      null,
      null,
      $donorExtensions,
      $recipientExtensions,
      $concurrent,
      true
    );

    return $q;
  }    


  /**
   * Returns query for schools that persons with positions in this Org have attended
   *
   * @return  Doctrine_Query  A query with the given constraints
   */ 
  public function getPersonSchoolsQuery($schoolExtensions=null, $personExtensions=null, $concurrent=false)
  {
    $q = $this->getSecondDegreeEntitiesQuery(
      1,
      2,
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      array(RelationshipTable::EDUCATION_CATEGORY),
      null,
      null,
      $personExtensions,
      $schoolExtensions,
      $concurrent,
      true
    );

    return $q;
  }  


  /**
   * Returns query for entities that have given to fundraising committees that have given to this entity
   *
   * @return  Doctrine_Query  A query with the given constraints
   */ 
  public function getIndirectDonorsQuery($donorExtensions=null, $fundraisingExtensions=null, $concurrent=false)
  {
    $q = $this->getSecondDegreeEntitiesQuery(
      1,
      1,
      array(RelationshipTable::DONATION_CATEGORY),
      array(RelationshipTable::DONATION_CATEGORY),
      null,
      null,
      $fundraisingExtensions,
      $donorExtensions,
      $concurrent,
      true
    );
    
    $q->select('e2.*, SUM(r1.amount) AS num')
      ->orderBy('num DESC');

    return $q;
  } 

  
  /**
   * Return a query for Entities that have Relationships to a given Entity and this Entity.
   * Eg, all the common organizations that this Entity and a given Entity have positions in.
   *
   * In the param definitions below, the following terms are used:
   *
   * Entity0:         This Entity
   * Entity1:         The entity with a relationship to Entity0 (one degree of separation)
   * Entity2:         The entity with a relationship to Entity1 (two degrees of separation)
   * Relationship1:   The Relationship between Entity and Entity1
   * Relationship2:   The Relationship between Entity1 and Entity2
   * 
   * This query is looking for Entity1s that match this pattern:
   * Entity0 <---(Relationship1)---> Entity1 <---(Relationship2)---> Entity2
   *
   * @param   Entity    $entity         Entity2
   * @param   integer   $order1         Order of Entity1 in Relationship1; can be 1, 2, or NULL
   * @param   integer   $order2         Order of Entity2 in Relationship2; can be 1, 2, or NULL
   * @param   mixed     $categoryIds1   Limits Relationship1 to one or more category_ids
   * @param   mixed     $categoryIds2   Limits Relationship2 to one or more category_ids
   * @param   mixed     $description1   A description to limit Relationship1
   * @param   mixed     $description2   A description to limit Relationship2
   * @param   mixed     $extensions1    Limits Entity1 to one or more extension names
   * @param   mixed     $extensions2    Limits Entity2 to one or more extension names
   * @param   boolean   $concurrent     Whether Relationship1 and Relationship2 must overlap in time; false by default
   *
   * @return  Doctrine_Query            A query with the given constraints
   */
  public function getCommonEntitiesQuery(
    Entity $entity, 
    $order1=null,
    $order2=null,
    $categoryIds1=null,
    $categoryIds2=null,
    $description1=null,
    $description2=null,
    $extensions=null, 
    $concurrent=false
  )
  {
    $q = LsDoctrineQuery::Create()
      ->from('Entity e1');
      
    if ($order2)
    {
      $q->innerJoin('e1.Relationship r2 ON r2.entity' . ($order2) . '_id = ?', $entity->id)
        ->addWhere('r2.entity' . (3 - $order2) . '_id = e1.id');
    }
    else
    {
      $q->innerJoin('e1.Relationship r2 ON e1.id IN (r2.entity1_id, r2.entity2_id)')
        ->addWhere('r2.entity1_id = ? OR r2.entity2_id = ?', array($entity->id, $entity->id));
    }
    
    if ($order1)
    {
      $q->innerJoin('e1.Relationship r1 ON r1.entity' . ($order1) . '_id = e1.id')
        ->addWhere('r1.entity' . (3- $order1) . '_id = ?' , $this->id);
    }
    else
    {
      $q->innerJoin('e1.Relationship r1 ON e1.id IN (r1.entity1_id, r2.entity2_id)')
        ->addWhere('r1.entity1_id = ? OR r1.entity2_id = ?', array($this->id, $this->id));
    }
        
    if ($categoryIds1) { $q->andWhereIn('r1.category_id', (array) $categoryIds1); }
    if ($categoryIds2) { $q->andWhereIn('r2.category_id', (array) $categoryIds2); }

    $q->groupBy('e1.id');
    
    if ($extensions)
    {
      LsQuery::addExtensionRequirement($q, $extensions, 'e1');
    }

    if ($concurrent)
    {
      LsQuery::addConcurrence($q);
    }
    
    return $q;
  }


  public function getCommonOrgsByPositionQuery(Entity $entity, $extensions=null, $concurrent=false)
  {
    return $this->getCommonEntitiesQuery(
      $entity,
      2,
      1,
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      null,
      null,
      $extensions,
      $concurrent
    );
  }
  
  
  public function getCommonPersonsByPositionQuery(Entity $entity, $extensions=null, $concurrent=false)
  {
    return $this->getCommonEntitiesQuery(
      $entity,
      1,
      2,
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      null,
      null,
      $extensions,
      $concurrent
    );
  }


  public function getCommonPersonsByPositionAndEducationQuery(Entity $entity, $extensions=null, $concurrent=false)
  {
    return $this->getCommonEntitiesQuery(
      $entity,
      1,
      2,
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      array(RelationshipTable::EDUCATION_CATEGORY),
      null,
      null,
      $extensions,
      $concurrent
    );
  }


  public function getCommonRecipientsQuery(Entity $entity, $extensions=null, $concurrent=false)
  {
    return $this->getCommonEntitiesQuery(
      $entity,
      2,
      1,
      array(RelationshipTable::DONATION_CATEGORY),
      array(RelationshipTable::DONATION_CATEGORY),
      null,
      null,
      $extensions,
      $concurrent
    );
  }


  public function getCommonDonorsQuery(Entity $entity, $extensions=null, $concurrent=false)
  {
    return $this->getCommonEntitiesQuery(
      $entity,
      1,
      2,
      array(RelationshipTable::DONATION_CATEGORY),
      array(RelationshipTable::DONATION_CATEGORY),
      null,
      null,
      $extensions,
      $concurrent
    );
  }


  public function getRecipientPersonsQuery(Entity $entity, $extensions=null, $concurrent=false)
  {
    return $this->getCommonEntitiesQuery(
      $entity,
      1,
      2,
      array(RelationshipTable::POSITION_CATEGORY, RelationshipTable::MEMBERSHIP_CATEGORY),
      array(RelationshipTable::DONATION_CATEGORY),
      null,
      null,
      $extensions,
      $concurrent
    );
  }


  public function addPhone($number, $type='phone')
  {
    //remove non-numerican chars from number
    if (!$number = PhoneTable::formatForDb($number))
    {
      return false;
    }


    //make sure Entity doesn't already have phone
    foreach ($this->Phone as $phone)
    {
      if ($phone->number == $number)
      {
        return false;
      }
    }
    
    
    //type must be phone or fax
    if (!in_array($type, PhoneTable::$types))
    {
      throw new Exception("Invalid phone type: " . $type);  
    }
    
    
    //create new phone
    $phone = new Phone;
    $phone->number = $number;
    $phone->type = $type;
    
    $this->Phone[] = $phone;

    
    return $phone;
  } 
  
  
  public function addAddress($address)
  {  
    if (!$address = AddressTable::standardize($address))
    {
      return false;
    }

    if ($this->exists())
    {
      if ($address->latitude && $address->longitude && AddressTable::getByCoordsQuery($address->longitude, $address->latitude, $this)->count())
      {
        return false;
      }
      else if (!$address->latitude && AddressTable::retrieveByAddress($address,false,$this))
      {
        return false;
      }
    }
    
    $this->Address[] = $address;

    return $address;
  }


  public function addEmail($address)
  {
    //make sure valid email address
    if (!EmailTable::isEmail($address))
    {
      return false;
    }


    //make sure Entity doesn't already have phone
    foreach ($this->Email as $email)
    {
      if ($email->address == $address)
      {
        return false;
      }
    }
    

    //create new phone
    $email = new Email;
    $email->address = $address;
    
    $this->Email[] = $email;
    

    return $email;
  } 

  
  
  public function getSimilarEntitiesQuery($looseMatch=false)
  {
    if (!$primary = $this->getPrimaryExtension())
    {
      throw new Exception("Can't find similar Entities for Entity without primary extension");
    }
    
    
    return call_user_func(array($primary . 'Table', 'getSimilarQuery'), $this, $looseMatch);
  }
  
  
  public function getAliasNames($includePrimary=false, $excludeContext = false)
  {
    return EntityTable::getAliasNamesById($this['id'], $includePrimary, $excludeContext);
  }
  
  
  public function getPrimaryAlias()
  {
    return LsDoctrineQuery::create()
      ->from('Alias a')
      ->where('a.entity_id = ? AND a.is_primary = ?', array($this->id, true))
      ->fetchOne();
  }
  
  
  public function hasName($name, $matchContext=false, $context=null)
  {
    return EntityTable::hasName($this, $name, $matchContext, $context);
  }


  public function setStartDate($str)
  {
    $this->_set('start_date', Dateable::convertForDb($str));
  }
  
  
  public function setEndDate($str)
  {
    $this->_set('end_date', Dateable::convertForDb($str));
  }


  public function getChildrenQuery()
  {
    if (!$this->id)
    {
      throw new Exception("Can't get children of new entity");
    }

    return LsDoctrineQuery::create()
      ->from('Entity e')
      ->where('e.parent_id = ?', $this->id);
  }
  
  public function getWatchersQuery()
  {

    $q = LsDoctrineQuery::create()
      ->select('r.id')
      ->from('Relationship r')
      ->where('r.entity1_id = ? OR r.entity2_id = ?', array($this->id, $this->id))
      ->addWhere('r.is_deleted IS NOT NULL');
      
    $results = $q->fetchArray();
    
    $ids = array();

    foreach ($results as $result)
    {
      $ids[] = $result['id'];
    }
    
    $q = LsDoctrineQuery::create()
        ->select('u.*, count(m.id) AS mods')
        ->from('sfGuardUser u')
        ->leftJoin('u.Profile p')
        ->leftJoin('u.Modification m')
        ->where('u.id > ? and u.is_super_admin = ? and p.watching_opt_out = ?', array(2, false, false))
        ->andWhere('m.object_model = ? and m.object_id = ?', array('Entity', $this->id));
        
     if (count($ids))
     {
       $q = $q->orWhere('m.object_model = ? and u.id > ? and u.is_super_admin = ? and p.watching_opt_out = ?', array('Relationship', 2, false, false))
        ->andWhereIn('m.object_id', $ids);
     }
      
     $q = $q->groupBy('u.id')
          ->orderBy('mods DESC');
        
    return $q;      
  }
  
  
  public function getRelationshipSummary()
  {
    $ret = array();

    if ($this->hasExtension('Person'))
    {
      $catNames = array(
        1 => 'Position',
        3 => 'Membership',
        2 => 'Education',
        5 => 'Donation/grant',
        6 => 'Transaction',
        7 => 'Lobbying',
        4 => 'Family',
        8 => 'Social',
        9 => 'Professional',
        10 => 'Ownership'
      );
    }
    else
    {
      $catNames = array(
        1 => 'Position',
        3 => 'Membership',
        2 => 'Education',
        5 => 'Donation/grant',
        6 => 'Transactions',
        7 => 'Lobbying',
        10 => 'Ownership' 
      );
    }

    $entity_relationships = $this->getEntitiesWithRelationships();
    
    foreach ($catNames as $catId => $catName)
    {
      $catAry = EntityTable::filterEntitiesWithRelationships(
        $entity_relationships,
        $catId
      );
      
      if (count($catAry))
      {
        $ret[$catName] = count($catAry);
      }
    }
      
    return $ret;
  }
  
  public function getAllNames()
  {
    $names = array($this->name);
    foreach($this->Alias as $alias)
    {
      $names[] = $alias->name;
    }
    $names = array_unique($names);
    return $names;
  }


  public function getRelatedPeopleWithImagesQuery()
  {
    return LsDoctrineQuery::create()
      ->from('Entity e')
      ->leftJoin('e.Relationship r1 ON (e.id = r1.entity1_id AND r1.entity2_id = ?)', $this->id)
      ->leftJoin('e.Relationship r2 ON (e.id = r2.entity2_id AND r2.entity1_id = ?)', $this->id)
      ->leftJoin('e.Image i')
      ->where('r1.entity1_id IS NOT NULL OR r2.entity2_id IS NOT NULL')
      ->andWhere('e.id <> ? AND e.primary_ext = ?', array($this->id, 'Person'))
      ->andWhere('i.is_featured = ?', true);
  }  
  

  public function getRelationshipIds()
  {
    return EntityTable::getRelationshipIds($this);
  }
  
  
  public function getAllReferences()
  {
    return EntityTable::getAllReferencesById($this->id);
  }
  
  public function nameSearch()
  {
    if ($this->primary_ext == 'Person')
    {
      return PersonTable::nameSearch($this->name);
    }
    else
    {
      return OrgTable::nameSearch($this->name);
    }
    
  }
  
  public function getExternalIds()
  {
    $q = LsDoctrineQuery::create()
          ->from('ExternalKey ek')
          ->where('ek.entity_id = ?', $this->id);
    $keys = $q->execute();
    $externalIds = array();
    foreach($keys as $key)
    {
      $externalIds[$key->Domain->name][] = $key->external_id;
    }
    return $externalIds;
  }
}